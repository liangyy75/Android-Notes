[设计模式系列博客](https://www.cnblogs.com/chenssy/category/482229.html)
[设计模式Markdown](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/设计模式.md)
[保护性拷贝](https://blog.csdn.net/one_jachen/article/details/78246047)
[六大原则](https://www.cnblogs.com/dolphin0520/p/3919839.html)

- 创建型
    - 单例模式 Singleton: private static instance + public getInstance
        - 懒汉式-线程不安全
        - 饿汉式-线程安全
        - 懒汉式-线程安全(synchronized)
        - 双重校验锁-线程安全
        - 静态内部类实现
        - 枚举实现
        - 优点: 全局只有一个，可以通过这个唯一实例在不同类之间实现消息通信或同步
        - 缺点: 但也是全局只有一个，无法创建更多，而且静态的代码生命周期与应用一样长
    - 简单工厂 Simple Factory: product interface + concreteProductXXX + factory(createProductXXX)
        - 优点: 可以通过一个工厂随意生产一系列对象，可以轻松的添加新的对象
        - 缺点: 添加新的对象时要修改工厂类，不符合开闭原则；过多对象时工程类的生产函数可能过于臃肿
    - 工厂方法 Factory Method: product interface + concreteProductXXX + factory interface(createProduct) + concreteFactoryXXX
        - 优点: 符合开闭原则，添加新的产品，只要添加新的工厂就行了
        - 缺点: 可能需要过多的工厂类和产品类
    - 抽象工厂 Abstract Factory: product interfaceXXX + concreteProductXXXYYY + factory interface(createProductXXX) + concreteFactoryYYY(createProductXXXYYY)
        - 优点: 可以生产产品族，即一个工厂生产一套产品，而且扩展也十分方便，符合开闭原则
        - 缺点: 可能需要过多的产品类和工厂类
    - 生成器/建造者 Builder: director(builderXXX.build()) + builderXXX interface + concreteBuilderXXX + product
        - 优点: 将建造过程抽象成方法与类，可以根据需要将它们组合排列成各种产品，而且添加新的流程也很方便
        - 缺点: 可能需要过多的方法或者类
    - 原型模式 Prototype: prototype interface(clone) + concreteObj 注意浅复制与深复制(是否将引用也完全复制了，还有注意保护性拷贝)
        - 优点: 可以方便的复制自身，不需要重新new了
- **行为型**
    - 责任链 Chain Of Responsibility: sender(createRequestXXX) + receiverXXX(链式，上一个receiver处理不了才给下一个，或者上一个以及处理完了就交给下一个)
        - 优点: 客户端不需要指令的具体接受者与处理者，只要传递信息给最开始的接受者就行了；可以随时随地的增加或者更改一个处理者，甚至可以更改处理者的顺序，增加了系统的灵活性；
            使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
        - 缺点: 可能一个指令信息需要经过一整条链，传递效率低
    - 命令 Command: invoker(commandXXX) + command interface + concreteCommandXXX + receiver/executor + client
        - 优点: 可以方便的添加新的命令；降低了系统耦合度，将接受者与请求者分离开来；让命令本身变得独立，参数化，动态替换化，灵活性大大增强
        - 缺点: 多了一层执行者invoker，命令传递与执行的效率降低；不符合开闭原则，添加新的命令需要修改执行者invoker
    - **解释器** Interpreter: expression interface + terminalExpression + expressionXXX + context + client
    - **迭代器** Iterator: aggregate interface(createIterator) + aggregateXXX + iterator interface + iteratorXXX
    - 中介者 Mediator: mediator interface + concreteMediator + colleague interface + colleagueXXX
        - 集中相关对象之间复杂的沟通和控制方式
        - 优点: 更好的解耦合了，多个对象只需要通过同一个中介者对象沟通就行了；可以方便的添加新的相关对象与相关对象间的关系，并在中介者中添加新的沟通方法就行了；
        - 缺点: 不符合开闭原则；多了一层媒介来沟通，信息传递与处理效率下降；过多的相关对象与相关关系时，中介者对象可能过于复杂；
    - **备忘录** Memento: originator + caretaker + menento
        - 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态
    - 观察者 Observer: subject interface(register/remove/notifyObserver) + observer interface(update) + ...
        - 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态
    - 状态 State: state interface(operationXXX()) + stateXXX(validOperationXXX()) + owner(state+stateXXX)
        - 优点: 可以方便的添加新的状态；可以更方便的管理状态的跃迁；可以将状态与状态管理者更好的解耦
        - 缺点: 可能有过多的状态类；不符合开闭原则
    - 策略 Strategy: strategy interface(behavior) + strategyXXX + context(setStrategy+doSomething(s.behavior))
        - 优点: 符合开闭原则，可以方便的添加新的策略；可以动态的替换策略；避免了多重条件选择语句，符合面向对象设计思想
        - 缺点: 可能需要过多的策略类；客户端需要知道所有的策略类
        - 与命令模式对比: 命令模式强调的是对已有行为的一个封装，而策略模式强调的是一系列未知算法的替换，这些算法需要独立的实现。
    - 模板方法 Template Method:
        - 优点: 可以最大程度的复用代码；符合开闭原则，可以轻松的添加新的类；符合单一职责原则，每个子类只需要负责独属于自己的那一部分逻辑
        - 缺点: 引用一个抽象类，如果具体实现过多的话，会导致系统复杂，混乱
    - **访问者** Visitor: element interface(accept(visitor)) + elementXXX + visitor interface(visitElementXXX(elementXXX)) + ...
        - 为一个对象结构(比如组合结构)增加新能力
    - 空对象 Null: 使用什么都不做的空对象来代替NULL。一个方法返回NULL，意味着方法的调用端需要去检查返回值是否是NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。
        - 优点: 不用再检查NULL，不会导致非常多的冗余的检查代码；不会发生因为忘记返回值检查而导致的空指针异常
        - 缺点: 更多的内存空间的消耗
- **结构型**
    - 适配器 Adapter: obj1 interface(do1) + obj2(do2) + obj1_2:obj1(do1(do2)) ==> obj2伪装成obj1了，用do2伪装成do1
        - 使得Handler可以与Messenger通信
    - **桥接** Bridge: a abstract(do) + b abstract(do) + aXXX(do) + bXXX(do(... + a.do + ...))
        - 遥控器的功能实现方法不是在遥控器中去实现了，而是将实现部分用来另一个电视机类去封装它，遥控器中只包含电视机类的一个引用，通过桥接模式，我们把抽象化和实现化部分分离开了，这样可以很好应对这两方面的变化。
        - 优点: 抽象接口与其实现解耦，期中的抽象和实现可以独立的进行扩展，不会影响到对方
        - 缺点: 添加了系统的复杂性
    - **组合** Composite: 组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。
        - 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。
        - 同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。
        - 作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。当然，这无疑会给叶子构件的实现带来麻烦。
        - 由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法，即在容器构件的operation()方法中递归调用其成员构件的operation()方法
    - 装饰 Decorator: 把装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。
        - 优点: 可以方便的添加新的功能，符合开闭原则；
        - 缺点: 与建造者模式相比，每多一些新的功能，就需要添加新的类，可能需要过多的类，无法想建造者一样一个Builder，在需要的时候调用需要的方法就行了。
    - 外观/门面 Facade: 通过一个简单的接口来访问一个复杂的系统，如鼠标键盘与内部CPU调度、硬盘读取和内存写入等等。
        - 优势: 符合最少知道原则；简单的接口便于访问与操作复杂的系统
    - 享元 Flyweight: 面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。
        - 模式的优点
            1. 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份； 
            2. 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。
        - 模式的缺点
            1. 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化； 
            2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
    - 代理 Proxy: 控制对其它对象的访问。拦截、处理外界的信息。
        - **静态代理**: 需要我们编码时就确定代理、被代理对象关系，如果有大量的或者运行时才确定的代理行为，静态代理就不太合适了；
        - **动态代理**: 使用反射，通过参数和代理方法自动生成代理的代码。
        - **Cglib代理**: https://www.cnblogs.com/zhangxufeng/p/9162182.html
        - 静态代理方式需要为每个接口实现一个代理类，而这些代理类中的代码几乎是一致的。这在大型系统中将会产生很大的维护问题。
        - jdk代理解决了静态代理需要为每个业务接口创建一个代理类的问题，虽然使用反射创建代理对象效率比静态代理稍低，但其在现代高速jvm中也是可以接受的；jdk代理的限制也是比较明显的，即其需要被代理的对象必须实现一个接口。
- 六大原则
    - 单一责任原则
    - 开闭原则
    - 里氏替换原则
    - 依赖倒置原则
    - 接口隔离原则
    - 迪米特法则

[TOC]

### 创建型

#### 单例模式(Singleton)

确保一个类只有一个实例，并提供该实例的全局访问点。

1. 懒汉式-线程不安全(多个线程能够同时进入 if (instance == null))
    ```java
    public class Singleton {
        private static Singleton instance;
        private Singleton() {}
        public static Singleton getInstance() {
            if (instance == null) instance = new Singleton();
            return instance;
        }
    }
    ```
2. 饿汉式-线程安全(丢失了延迟实例化带来的节约资源的好处)
    ```java
    private static Singleton instance = new Singleton();
    ```
3. 懒汉式-线程安全
    ```java
    public static synchronized Singleton getInstance() { /* ... */ }
    // 当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使instance已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。
    ```
4. 双重校验锁-线程安全
    ```java
    private volatile static Singleton instance;
    // instance 采用 volatile 关键字修饰也是很有必要的， instance = new Singleton(); 这段代码其实是分为三步执行
    //   1. 为 instance 分配内存空间
    //   2. 初始化 instance
    //   3. 将 instance 指向分配的内存地址
    // 但是由于JVM具有指令重排的特性，执行顺序有可能变成132。指令重排在单线程环境下不会出现问题，但是在多线程环境下会
    // 导致一个线程获得还没有初始化的实例。例如，线程T1执行了1和3，此时T2调用getInstance()后发现instance不为空，因此
    // 返回instance，但此时instance还未被初始化。使用volatile可以禁止JVM的指令重排，保证在多线程环境下也能正常运行。
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) instance = new Singleton();
                // 因为如果多个线程同时满足了instance == null的条件，会相继进入synchronized代码块，所以里面也还需要if判断
            }
        }
        return instance
    }
    ```
5. 静态内部类实现: 当Singleton类加载时，静态内部类SingletonHolder没有被加载进内存。只有当调用getInstance()方法从而触发SingletonHolder.INSTANCE时SingletonHolder才会被加载，此时初始化INSTANCE实例，并且JVM能确保INSTANCE只被实例化一次。这种方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持。
    ```java
    public class Singleton {
        private Singleton() {}
        private static class SingletonHolder {
            private static final Singleton INSTANCE = new Singleton();
        }
        public static Singleton getInstance() {
            return SingletonHolder.INSTANCE;
        }
    }
    ```
6. 枚举实现
    ```java
    public enum Singleton {
        INSTANCE;
        private String objName;
        public String getObjName() {
            return objName;
        }
        public void setObjName(String objName) {
            this.objName = objName;
        }
        public static void main(String[] args) {
            // 单例测试
            Singleton firstSingleton = Singleton.INSTANCE;
            firstSingleton.setObjName("firstName");
            System.out.println(firstSingleton.getObjName());
            Singleton secondSingleton = Singleton.INSTANCE;
            secondSingleton.setObjName("secondName");
            System.out.println(firstSingleton.getObjName());
            System.out.println(secondSingleton.getObjName());
            // 反射获取实例测试
            try {
                Singleton[] enumConstants = Singleton.class.getEnumConstants();
                for (Singleton enumConstant : enumConstants) {
                    System.out.println(enumConstant.getObjName());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    // 该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用transient修饰所有字段，
    // 并且实现序列化和反序列化的方法。该实现可以防止反射攻击。在其它实现中要防止这种攻击，需要在构造函
    // 数中添加防止多次实例化的代码。该实现是由JVM保证只会实例化一次，因此不会出现上述的反射攻击。
    ```
7. Examples
    - Logger Classes
    - Configuration Classes
    - Accesing resources in shared mode
    - Factories implemented as Singletons
8. JDK
    - [java.lang.Runtime#getRuntime()](http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29)
    - [java.awt.Desktop#getDesktop()](http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--)
    - [java.lang.System#getSecurityManager()](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--)

#### 简单工厂(Simple Factory)

在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。<br>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。

```java
public interface Product {}
public class ConcreteProduct implements Product {}
public class ConcreteProduct1 implements Product {}
public class ConcreteProduct2 implements Product {}
// 以下的Client类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。
public class Client {
    public static void main(String[] args) {
        int type = 1;
        Product product;
        if (type == 1) {
            product = new ConcreteProduct1();
        } else if (type == 2) {
            product = new ConcreteProduct2();
        } else {
            product = new ConcreteProduct();
        }
        // do something with the product
    }
}
// 以下的SimpleFactory是简单工厂实现，它被所有需要进行实例化的客户类调用。
public class SimpleFactory {
    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
public class Client {
    public static void main(String[] args) {
        SimpleFactory simpleFactory = new SimpleFactory();
        Product product = simpleFactory.createProduct(1);
        // do something with the product
    }
}
```

#### 工厂方法(Factory Method)

简单工厂模式实现了生成产品类的代码跟客户端代码分离，在工厂类中你可以添加所需的生成产品的逻辑代码，但是问题来了，优秀的java代码是符合“开放-封闭”原则的，也就是说**对扩展开发，对修改关闭**，如果你要加一个产品类C，你就要修改工厂类里面的生成产品的代码，在这里你就要增加if-else判断。对于这个问题，我们的工厂方法模式就可以解决这个问题。

定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。<br>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由factoryMethod()方法创建。该方法是抽象的，需要由子类去实现。
<div class="align"><img alt="Factory Method" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1818e141-8700-4026-99f7-900a545875f5.png"/></div>

1. 实现
    ```java
    public abstract class Factory {
        abstract public Product factoryMethod();
        public void doSomething() {
            Product product = factoryMethod();
            // do something with the product
        }
    }
    public class ConcreteFactory extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct();
        }
    }
    public class ConcreteFactory1 extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct1();
        }
    }
    public class ConcreteFactory2 extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct2();
        }
    }
    ```
2. JDK
    - [java.util.Calendar](http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)
    - [java.util.ResourceBundle](http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-)
    - [java.text.NumberFormat](http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--)
    - [java.nio.charset.Charset](http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-)
    - [java.net.URLStreamHandlerFactory](http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-)
    - [java.util.EnumSet](https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-)
    - [javax.xml.bind.JAXBContext](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--)

#### 抽象工厂(Abstract Factory)

工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类，在这里我们就可以实现“开发-封闭”原则，无论加多少产品类，我们都不用修改原来类中的代码，而是通过增加工厂类来实现。但是这还是有缺点的，如果产品类过多，我们就要生成很多的工厂类。假如我们要实现的产品接口不止一个，也就是有多个产品接口，不同产品接口有对应的产品族。什么是产品族呢？简单的理解就是，不同牌子产的车里面会有跑车类型，家庭类型，商用类型等的车，不同牌子的车的跑车类型的车可以组成一个产品族。对于这种情况我们可以采用抽象工厂模式。

提供一个接口，用于创建**相关的对象家族**。

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象。<br>
抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA()和createProductB()方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。<br>
至于创建对象的家族这一概念是在Client体现，Client要通过AbstractFactory同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client需要同时创建出这两个对象。<br>
从高层次来看，抽象工厂使用了组合，即Cilent组合了AbstractFactory，而工厂方法模式使用了继承。
<div class="align"><img alt="Abstract Factory" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png"/></div>

1. 实现
    ```java
    public class AbstractProductA {}
    public class AbstractProductB {}
    public class ProductA1 extends AbstractProductA {}
    public class ProductA2 extends AbstractProductA {}
    public class ProductB1 extends AbstractProductB {}
    public class ProductB2 extends AbstractProductB {}
    public abstract class AbstractFactory {
        abstract AbstractProductA createProductA();
        abstract AbstractProductB createProductB();
    }
    public class ConcreteFactory1 extends AbstractFactory {
        AbstractProductA createProductA() {
            return new ProductA1();
        }
        AbstractProductB createProductB() {
            return new ProductB1();
        }
    }
    public class ConcreteFactory2 extends AbstractFactory {
        AbstractProductA createProductA() {
            return new ProductA2();
        }
        AbstractProductB createProductB() {
            return new ProductB2();
        }
    }
    public class Client {
        public static void main(String[] args) {
            AbstractFactory abstractFactory = new ConcreteFactory1();
            AbstractProductA productA = abstractFactory.createProductA();
            AbstractProductB productB = abstractFactory.createProductB();
            // do something with productA and productB
        }
    }
    ```
2. JDK
    - [javax.xml.parsers.DocumentBuilderFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html)
    - [javax.xml.transform.TransformerFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--)
    - [javax.xml.xpath.XPathFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--)
3. 优越性: 抽象工厂模式中我们可以定义实现不止一个接口，一个工厂也可以生成不止一个产品类，抽象工厂模式较好的实现了“开放-封闭”原则，是三个模式中较为抽象，并具一般性的模式。我们在使用中要注意使用抽象工厂模式的条件。

#### 生成器/建造者(Builder)

将一个复杂的对象，分成多分，使同样的构建过程，能有不同的表示。生成器模式的核心是**当构建生成一个对象的时候，需要包含多个步骤，虽然每个步骤具体的实现不同，但是都遵循一定的流程与规则**。<br>
举个例子，我们如果构建生成一台电脑，那么我们可能需要这么几个步骤: 需要一个主机; 需要一个显示器; 需要一个键盘; 需要一个鼠标; 需要音响等; 虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。<br>
但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。<br>
所以，我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件(Component)组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。

**https://www.jianshu.com/p/f4248525e2d1**

封装一个对象的构造过程，并允许按步骤构造。<div class="align"><img alt="Builder" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png"/></div>

1. 以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。
    ```java
    public class AbstractStringBuilder {
        protected char[] value;
        protected int count;
        public AbstractStringBuilder(int capacity) {
            count = 0;
            value = new char[capacity];
        }
        public AbstractStringBuilder append(char c) {
            ensureCapacityInternal(count + 1);
            value[count++] = c;
            return this;
        }
        private void ensureCapacityInternal(int minimumCapacity) {
            if (minimumCapacity - value.length > 0)
                expandCapacity(minimumCapacity);
        }
        void expandCapacity(int minimumCapacity) {
            int newCapacity = value.length * 2 + 2;
            if (newCapacity - minimumCapacity < 0)
                newCapacity = minimumCapacity;
            if (newCapacity < 0) {
                if (minimumCapacity < 0) // overflow
                    throw new OutOfMemoryError();
                newCapacity = Integer.MAX_VALUE;
            }
            value = Arrays.copyOf(value, newCapacity);
        }
    }
    public class StringBuilder extends AbstractStringBuilder {
        public StringBuilder() {
            super(16);
        }
        @Override
        public String toString() {
            // Create a copy, don't share the array
            return new String(value, 0, count);
        }
    }
    public class Client {
        public static void main(String[] args) {
            StringBuilder sb = new StringBuilder();
            final int count = 26;
            for (int i = 0; i < count; i++) {
                sb.append((char) ('a' + i));
            }
            System.out.println(sb.toString());  // abcdefghijklmnopqrstuvwxyz
        }
    }
    ```
2. JDK
    - [java.lang.StringBuilder](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)
    - [java.nio.ByteBuffer](http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-)
    - [java.lang.StringBuffer](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-)
    - [java.lang.Appendable](http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html)
    - [Apache Camel builders](https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder)
3. 优点: 将一个对象分解为各个组件; 将对象组件的构造封装起来; 可以控制整个对象的生成过程。缺点: 对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量。
4. 生成器模式的实际应用: 生成器模式在许多类库中都使用了。但是严格来说，却有些错误。在标准库中，StringBuilder继承自AbstractStringBuilder
append方法是这个生成过程中的一步，就像我们构建电脑时，先构建主机这样的步骤一样。toString方法也是生成过程中的一步，而且是构建过程中的最后一步。然而，这里的不同是没有director，所以严格来说这不是一个标准的生成器模式。我们程序的调用者好像就是director可以生成我们自己的String。
5. 生成器模式与工厂模式的不同: 生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。

#### 原型模式(Prototype)

在应用程序中，有些对象比较复杂，其创建过程过于复杂，而且我们又需要频繁的利用该对象，如果这个时候我们按照常规思维new该对象，那么务必会带来非常多的麻烦，这个时候我们就希望可以利用一个已有的对象来不断对他进行复制就好了，这就是编程中的“克隆”。这里原型模式就可以满足我们的“克隆”，在原型模式中我们可以利用过一个原型对象来指明我们所要创建对象的类型，然后通过复制这个对象的方法来获得与该对象一模一样的对象实例。这就是原型模式的设计目的。

使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。<div class="align"><img alt="Prototype" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a40661e4-1a71-46d2-a158-ff36f7fc3331.png"/></div>

- 实现:
    ```java
    public abstract class Prototype {
        abstract Prototype myClone();
    }
    public class ConcretePrototype extends Prototype {
        private String filed;
        public ConcretePrototype(String filed) {
            this.filed = filed;
        }
        @Override
        Prototype myClone() {
            return new ConcretePrototype(filed);
        }
        @Override
        public String toString() {
            return filed;
        }
    }
    public class Client {
        public static void main(String[] args) {
            Prototype prototype = new ConcretePrototype("abc");
            Prototype clone = prototype.myClone();
            System.out.println(clone.toString());   // abc
        }
    }
    ```
- JDK: [java.lang.Object#clone()](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29)

### 行为型

#### 责任链(Chain Of Responsibility)

去年参加校招要到长沙来，这个对于我来说不是特别喜欢(但又必须的来，谁叫咱不是985、211的娃呢)，但是对于某些人来说就是福音了。大四还有课，而且学校抓的比较严，所以对于那些想翘课的人来说这个是最好不过的理由了—去参加校招了。所以咱学校规定所以去参加校招的必须要请假，且必须要有相关人员的签字，三天一下，辅导员签字、三到七天系主任签字，一个星期以上院长签字，更多？校长(不知道能不能找到校长呢？反正我是没见校长几面)，出了这样的政策确实上课情况好多了！对于这中将请求一级一级地往上传递直到处理请求为止的设计模式就是职责链模式。

将学生、辅导员、系主任、院长、校长组成了一个简单的链。在这个链上，学生是申请者，其余的都是请求处理者。职责链可以将请求的处理者组织成一条链，并且将请求沿着链传递，如果某个请求处理者能够处理请求则处理，否则将该请求交由上级处理。

职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了，这就是职责链的设计动机。**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止**，这就是职责链模式。

在职责链模式中最关键的一点就是客户提交请求后，请求沿着链往下传递直到有一个处理者处理它，在这里客户无需关心它的请求是哪个处理者来处理，反正总有一个处理者会处理它的请求。在这里客户端和处理者都没有对方明确的信息，同时处理者也不知道职责链中的结构。所以职责链可以简化对象的相互连接，他们只需要保存一个指向其后续者的引用，而不需要保存所有候选者的引用。

在职责链模式中我们可以随时随地的增加或者更改一个处理者，甚至可以更改处理者的顺序，增加了系统的灵活性。处理灵活性是增加了，但是有时候可能会导致一个请求无论如何也得不到处理，它会被放置在链末端，这个既是职责链的优点也是缺点。

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。

Handler: 定义处理请求的接口，并且实现后继链(successor)<div class="align"><img alt="Chain of Responsibility" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/691f11eb-31a7-46be-9de1-61f433c4b3c7.png"/></div>

- 实现:
    ```java
    public abstract class Handler {
        protected Handler successor;
        public Handler(Handler successor) {
            this.successor = successor;
        }
        protected abstract void handleRequest(Request request);
    }
    public class ConcreteHandler1 extends Handler {
        public ConcreteHandler1(Handler successor) {
            super(successor);
        }
        @Override
        protected void handleRequest(Request request) {
            if (request.getType() == RequestType.TYPE1) {
                System.out.println(request.getName() + " is handle by ConcreteHandler1");
                return;
            }
            if (successor != null)
                successor.handleRequest(request);
        }
    }
    public class ConcreteHandler2 extends Handler {
        public ConcreteHandler2(Handler successor) {
            super(successor);
        }
        @Override
        protected void handleRequest(Request request) {
            if (request.getType() == RequestType.TYPE2) {
                System.out.println(request.getName() + " is handle by ConcreteHandler2");
                return;
            }
            if (successor != null)
                successor.handleRequest(request);
        }
    }
    public class Request {
        private RequestType type;
        private String name;
        public Request(RequestType type, String name) {
            this.type = type;
            this.name = name;
        }
        public RequestType getType() {
            return type;
        }
        public String getName() {
            return name;
        }
    }
    public enum RequestType {
        TYPE1, TYPE2
    }
    public class Client {
        public static void main(String[] args) {
            Handler handler1 = new ConcreteHandler1(null);
            Handler handler2 = new ConcreteHandler2(handler1);
            Request request1 = new Request(RequestType.TYPE1, "request1");
            handler2.handleRequest(request1);   // request1 is handle by ConcreteHandler1
            Request request2 = new Request(RequestType.TYPE2, "request2");
            handler2.handleRequest(request2);   // request2 is handle by ConcreteHandler2
        }
    }
    ```
- JDK
    - [java.util.logging.Logger#log()](http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29)
    - [Apache Commons Chain](https://commons.apache.org/proper/commons-chain/index.html)
    - [javax.servlet.Filter#doFilter()](http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)

#### 命令(Command)

命令模式的本质就在于将命令进行封装，将发出命令的责任和执行命令的责任分开，是的发送者只需要知道如何发送命令即可，不需要命令是如何实现的，甚至命令执行是否成功都不需要理会。同时命令模式使得请求也变成了一个对象，它像其他对象一样可以被存储和传递。

- 基本定义: 将命令封装成对象中，具有以下作用: 
    - 使用命令来参数化其它对象
    - 将命令放入队列中进行排队
    - 将命令的操作记录到日志中
    - 支持可撤销的操作
- 类图: <div class="align"><img alt="Command" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ae1b27b8-bc13-42e7-ac12-a2242e125499.png"/></div>
    - Command: 命令抽象类
    - ConcreteCommand: 具体命令类
    - Receiver: 命令接收者，也就是命令真正的执行者
    - Invoker: 通过它来调用命令
    - Client: 可以设置命令与命令的接收者
- 实现: 设计一个遥控器，可以控制电灯开关。
    ```java
    public interface Command {
        void execute();
    }
    public class LightOnCommand implements Command {
        Light light;
        public LightOnCommand(Light light) {
            this.light = light;
        }
        @Override
        public void execute() {
            light.on();
        }
    }
    public class LightOffCommand implements Command {
        Light light;
        public LightOffCommand(Light light) {
            this.light = light;
        }
        @Override
        public void execute() {
            light.off();
        }
    }
    public class Light {
        public void on() {
            System.out.println("Light is on!");
        }
        public void off() {
            System.out.println("Light is off!");
        }
    }
    public class Invoker {
        private Command[] onCommands;
        private Command[] offCommands;
        private final int slotNum = 7;
        public Invoker() {
            this.onCommands = new Command[slotNum];
            this.offCommands = new Command[slotNum];
        }
        public void setOnCommand(Command command, int slot) {
            onCommands[slot] = command;
        }
        public void setOffCommand(Command command, int slot) {
            offCommands[slot] = command;
        }
        public void onButtonWasPushed(int slot) {
            onCommands[slot].execute();
        }
        public void offButtonWasPushed(int slot) {
            offCommands[slot].execute();
        }
    }
    public class Client {
        public static void main(String[] args) {
            Invoker invoker = new Invoker();
            Light light = new Light();
            Command lightOnCommand = new LightOnCommand(light);
            Command lightOffCommand = new LightOffCommand(light);
            invoker.setOnCommand(lightOnCommand, 0);
            invoker.setOffCommand(lightOffCommand, 0);
            invoker.onButtonWasPushed(0);
            invoker.offButtonWasPushed(0);
        }
    }
    ```
- JDK
    - [java.lang.Runnable](http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html)
    - [Netflix Hystrix](https://github.com/Netflix/Hystrix/wiki)
    - [javax.swing.Action](http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html)
- 优点: 降低了系统耦合度; 新的命令可以很容易添加到系统中去。缺点: 使用命令模式可能会导致某些系统有过多的具体命令类。

#### 解释器(Interpreter)

- 定义: 为语言创建解释器，通常由语言的语法和语法分析来定义。解释器模式就是，把事物高频率的特征和符号都通过解释器来解释，并加以组合处理。
- 类图: <div class="align"><img alt="Interpreter" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/794239e3-4baf-4aad-92df-f02f59b2a6fe.png"/></div>
    - TerminalExpression: 终结符表达式，每个终结符都需要一个 TerminalExpression。
    - Context: 上下文，包含解释器之外的一些全局信息。
- 实现: 以下是一个规则检验器实现，具有and和or规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。例如一颗解析树为D And (A Or (BC))，文本"DA"满足该解析树定义的规则。这里的Context指的是String。
    ```java
    public abstract class Expression {
        public abstract boolean interpret(String str);
    }
    public class TerminalExpression extends Expression {
        private String literal = null;
        public TerminalExpression(String str) {
            literal = str;
        }
        public boolean interpret(String str) {
            StringTokenizer st = new StringTokenizer(str);
            while (st.hasMoreTokens()) {
                String test = st.nextToken();
                if (test.equals(literal))
                    return true;
            }
            return false;
        }
    }
    public class AndExpression extends Expression {
        private Expression expression1 = null;
        private Expression expression2 = null;
        public AndExpression(Expression expression1, Expression expression2) {
            this.expression1 = expression1;
            this.expression2 = expression2;
        }
        public boolean interpret(String str) {
            return expression1.interpret(str) && expression2.interpret(str);
        }
    }
    public class OrExpression extends Expression {
        private Expression expression1 = null;
        private Expression expression2 = null;
        public OrExpression(Expression expression1, Expression expression2) {
            this.expression1 = expression1;
            this.expression2 = expression2;
        }
        public boolean interpret(String str) {
            return expression1.interpret(str) || expression2.interpret(str);
        }
    }
    public class Client {
        /**
         * 构建解析树
         */
        public static Expression buildInterpreterTree() {
            // Literal
            Expression terminal1 = new TerminalExpression("A");
            Expression terminal2 = new TerminalExpression("B");
            Expression terminal3 = new TerminalExpression("C");
            Expression terminal4 = new TerminalExpression("D");
            // B C
            Expression alternation1 = new OrExpression(terminal2, terminal3);
            // A Or (B C)
            Expression alternation2 = new OrExpression(terminal1, alternation1);
            // D And (A Or (B C))
            return new AndExpression(terminal4, alternation2);
        }
        public static void main(String[] args) {
            Expression define = buildInterpreterTree();
            String context1 = "D A";
            String context2 = "A B";
            System.out.println(define.interpret(context1)); // true
            System.out.println(define.interpret(context2)); // false
        }
    }
    ```
- JDK
    - [java.util.Pattern](http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
    - [java.text.Normalizer](http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html)
    - All subclasses of [java.text.Format](http://docs.oracle.com/javase/8/docs/api/java/text/Format.html)
    - [javax.el.ELResolver](http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html)
- 优点: 随时可以增加新的解释器而不会影响到现有的结构和类，便于扩展和维护。比如说可以很方便的增加一个新的求模的表达式来支持求商，或者可以修改除法表达式，当除数为0时，抛出异常等等，都是很方便的。缺点: 解释的时候采用递归调用方法，导致有时候函数的深度会很深，影响效率；需要建大量的类，因为每一种语法都要建一个非终结符的类。

#### 迭代器(Iterator)

- 定义: 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
- 类图: <div class="align"><img alt="Iterator" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/b0f61ac2-a4b6-4042-9cf0-ccf4238c1ff7.png"/></div>
    - Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；
    - Iterator 主要定义了 hasNext() 和 next() 方法。
    - Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。
- 实现:
    ```java
    public interface Aggregate {
        Iterator createIterator();
    }
    public class ConcreteAggregate implements Aggregate {
        private Integer[] items;
        public ConcreteAggregate() {
            items = new Integer[10];
            for (int i = 0; i < items.length; i++)
                items[i] = i;
        }
        @Override
        public Iterator createIterator() {
            return new ConcreteIterator<Integer>(items);
        }
    }
    public interface Iterator<Item> {
        Item next();
        boolean hasNext();
    }
    public class ConcreteIterator<Item> implements Iterator {
        private Item[] items;
        private int position = 0;
        public ConcreteIterator(Item[] items) {
            this.items = items;
        }
        @Override
        public Object next() {
            return items[position++];
        }
        @Override
        public boolean hasNext() {
            return position < items.length;
        }
    }
    public class Client {
        public static void main(String[] args) {
            Aggregate aggregate = new ConcreteAggregate();
            Iterator<Integer> iterator = aggregate.createIterator();
            while (iterator.hasNext())
                System.out.println(iterator.next());
        }
    }
    ```
- JDK
    - [java.util.Iterator](http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)
    - [java.util.Enumeration](http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html)

#### 中介者(Mediator)

- 定义: 集中相关对象之间复杂的沟通和控制方式。
- 类图: <div class="align"><img alt="Mediator" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/d0afdd23-c9a5-4d1c-9b3d-404bff3bd0d1.png"/></div>
    - Mediator: 中介者，定义一个接口用于与各同事(Colleague)对象通信。
    - Colleague: 同事，相关对象
- 实现: Alarm(闹钟)、CoffeePot(咖啡壶)、Calendar(日历)、Sprinkler(喷头)是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构: <div class="align"><img alt="Mediator Implemetation1" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg"/></div>使用中介者模式可以将复杂的依赖结构变成星形结构: <div class="align"><img alt="Mediator Implemetation2" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg"/></div>
    ```java
    public abstract class Colleague {
        public abstract void onEvent(Mediator mediator);
    }
    public class Alarm extends Colleague {
        @Override
        public void onEvent(Mediator mediator) {
            mediator.doEvent("alarm");
        }
        public void doAlarm() {
            System.out.println("doAlarm()");
        }
    }
    public class CoffeePot extends Colleague {
        @Override
        public void onEvent(Mediator mediator) {
            mediator.doEvent("coffeePot");
        }
        public void doCoffeePot() {
            System.out.println("doCoffeePot()");
        }
    }
    public class Calender extends Colleague {
        @Override
        public void onEvent(Mediator mediator) {
            mediator.doEvent("calender");
        }
        public void doCalender() {
            System.out.println("doCalender()");
        }
    }
    public class Sprinkler extends Colleague {
        @Override
        public void onEvent(Mediator mediator) {
            mediator.doEvent("sprinkler");
        }
        public void doSprinkler() {
            System.out.println("doSprinkler()");
        }
    }
    public abstract class Mediator {
        public abstract void doEvent(String eventType);
    }
    public class ConcreteMediator extends Mediator {
        private Alarm alarm;
        private CoffeePot coffeePot;
        private Calender calender;
        private Sprinkler sprinkler;
        public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
            this.alarm = alarm;
            this.coffeePot = coffeePot;
            this.calender = calender;
            this.sprinkler = sprinkler;
        }
        @Override
        public void doEvent(String eventType) {
            switch (eventType) {
                case "alarm":
                    doAlarmEvent();
                    break;
                case "coffeePot":
                    doCoffeePotEvent();
                    break;
                case "calender":
                    doCalenderEvent();
                    break;
                default:
                    doSprinklerEvent();
            }
        }
        public void doAlarmEvent() {
            alarm.doAlarm();
            coffeePot.doCoffeePot();
            calender.doCalender();
            sprinkler.doSprinkler();
        }
        public void doCoffeePotEvent() {
            // ...
        }
        public void doCalenderEvent() {
            // ...
        }
        public void doSprinklerEvent() {
            // ...
        }
    }
    public class Client {
        public static void main(String[] args) {
            Alarm alarm = new Alarm();
            CoffeePot coffeePot = new CoffeePot();
            Calender calender = new Calender();
            Sprinkler sprinkler = new Sprinkler();
            Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
            // 闹钟事件到达，调用中介者就可以操作相关对象
            alarm.onEvent(mediator);
            // doAlarm()
            // doCoffeePot()
            // doCalender()
            // doSprinkler()
        }
    }
    ```
- JDK
    - All scheduleXXX() methods of [java.util.Timer](http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html)
    - [java.util.concurrent.Executor#execute()](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-)
    - submit() and invokeXXX() methods of [java.util.concurrent.ExecutorService](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html)
    - scheduleXXX() methods of [java.util.concurrent.ScheduledExecutorService](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html)
    - [java.lang.reflect.Method#invoke()](http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-)

#### 备忘录(Memento)

- 定义: 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。
- 类图: <div class="align"><img alt="Memento" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/867e93eb-3161-4f39-b2d2-c0cd3788e194.png"/></div>
    - Originator: 原始对象
    - Caretaker: 负责保存好备忘录
    - Menento: 备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给Caretaker的窄接口: 它只能将备忘录传递给其它对象；一个是提供给Originator的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许Originator访问本备忘录的内部状态。
- 实现: 以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。实现参考: [Memento Pattern - Calculator Example - Java Sourcecode](https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html)
    ```java
    // Originator Interface
    public interface Calculator {
        // Create Memento
        PreviousCalculationToCareTaker backupLastCalculation();
        // setMemento
        void restorePreviousCalculation(PreviousCalculationToCareTaker memento);
        int getCalculationResult();
        void setFirstNumber(int firstNumber);
        void setSecondNumber(int secondNumber);
    }
    // Originator Implementation
    public class CalculatorImp implements Calculator {
        private int firstNumber;
        private int secondNumber;
        @Override
        public PreviousCalculationToCareTaker backupLastCalculation() {
            // create a memento object used for restoring two numbers
            return new PreviousCalculationImp(firstNumber, secondNumber);
        }
        @Override
        public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
            this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
            this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
        }
        @Override
        public int getCalculationResult() {
            // result is adding two numbers
            return firstNumber + secondNumber;
        }
        @Override
        public void setFirstNumber(int firstNumber) {
            this.firstNumber = firstNumber;
        }
        @Override
        public void setSecondNumber(int secondNumber) {
            this.secondNumber = secondNumber;
        }
    }
    // Memento Interface to Originator. This interface allows the originator to restore its state
    public interface PreviousCalculationToOriginator {
        int getFirstNumber();
        int getSecondNumber();
    }
    //  Memento interface to CalculatorOperator (Caretaker)
    public interface PreviousCalculationToCareTaker {
        // no operations permitted for the caretaker
    }
    // Memento Object Implementation <p>Note that this object implements both interfaces to Originator and CareTaker
    public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
            PreviousCalculationToOriginator {
        private int firstNumber;
        private int secondNumber;
        public PreviousCalculationImp(int firstNumber, int secondNumber) {
            this.firstNumber = firstNumber;
            this.secondNumber = secondNumber;
        }
        @Override
        public int getFirstNumber() {
            return firstNumber;
        }
        @Override
        public int getSecondNumber() {
            return secondNumber;
        }
    }
    // CareTaker object
    public class Client {
        public static void main(String[] args) {
            // program starts
            Calculator calculator = new CalculatorImp();
            // assume user enters two numbers
            calculator.setFirstNumber(10);
            calculator.setSecondNumber(100);
            // find result
            System.out.println(calculator.getCalculationResult());
            // Store result of this calculation in case of error
            PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();
            // user enters a number
            calculator.setFirstNumber(17);
            // user enters a wrong second number and calculates result
            calculator.setSecondNumber(-290);
            // calculate result
            System.out.println(calculator.getCalculationResult());
            // user hits CTRL + Z to undo last operation and see last result
            calculator.restorePreviousCalculation(memento);
            // result restored
            System.out.println(calculator.getCalculationResult());
        }
    }
    ```
- JDK: java.io.Serializable

#### 观察者(Observer)

- 定义: 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。主题(Subject)是被观察的对象，而其所有依赖者(Observer)称为观察者。
- 类图: <div class="align"><img alt="Observer" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0df5d84c-e7ca-4e3a-a688-bb8e68894467.png"/></div>主题(Subject)具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。观察者(Observer)的注册功能需要调用主题的registerObserver()方法。
- 实现: 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。
    ```java
    public interface Observer {
        void update(float temp, float humidity, float pressure);
    }
    public interface Subject {
        void registerObserver(Observer o);
        void removeObserver(Observer o);
        void notifyObserver();
    }
    public class WeatherData implements Subject {
        private List<Observer> observers;
        private float temperature;
        private float humidity;
        private float pressure;
        public WeatherData() {
            observers = new ArrayList<>();
        }
        public void setMeasurements(float temperature, float humidity, float pressure) {
            this.temperature = temperature;
            this.humidity = humidity;
            this.pressure = pressure;
            notifyObserver();
        }
        @Override
        public void registerObserver(Observer o) {
            observers.add(o);
        }
        @Override
        public void removeObserver(Observer o) {
            int i = observers.indexOf(o);
            if (i >= 0)
                observers.remove(i);
        }
        @Override
        public void notifyObserver() {
            for (Observer o : observers)
                o.update(temperature, humidity, pressure);
        }
    }
    public class StatisticsDisplay implements Observer {
        public StatisticsDisplay(Subject weatherData) {
            weatherData.reisterObserver(this);
        }
        @Override
        public void update(float temp, float humidity, float pressure) {
            System.out.println("StatisticsDisplay.update: " + temp + " " + humidity + " " + pressure);
        }
    }
    public class CurrentConditionsDisplay implements Observer {
        public CurrentConditionsDisplay(Subject weatherData) {
            weatherData.registerObserver(this);
        }
        @Override
        public void update(float temp, float humidity, float pressure) {
            System.out.println("CurrentConditionsDisplay.update: " + temp + " " + humidity + " " + pressure);
        }
    }
    public class WeatherStation {
        public static void main(String[] args) {
            WeatherData weatherData = new WeatherData();
            CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
            StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
            weatherData.setMeasurements(0, 0, 0);
            // CurrentConditionsDisplay.update: 0.0 0.0 0.0
            // StatisticsDisplay.update: 0.0 0.0 0.0
            weatherData.setMeasurements(1, 1, 1);
            // CurrentConditionsDisplay.update: 1.0 1.0 1.0
            // StatisticsDisplay.update: 1.0 1.0 1.0
        }
    }
    ```
- JDK
    - [java.util.Observer](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)
    - [java.util.EventListener](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)
    - [javax.servlet.http.HttpSessionBindingListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)
    - [RxJava](https://github.com/ReactiveX/RxJava)

#### 状态(State)

- 定义: 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。
- 类图: <div class="align"><img alt="State" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c5085437-54df-4304-b62d-44b961711ba7.png"/></div>
- 实现: 糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。
    ```java
    public interface State {
        // 投入 25 分钱
        void insertQuarter();
        // 退回 25 分钱
        void ejectQuarter();
        // 转动曲柄
        void turnCrank();
        // 发放糖果
        void dispense();
    }
    public class HasQuarterState implements State {
        private GumballMachine gumballMachine;
        public HasQuarterState(GumballMachine gumballMachine) {
            this.gumballMachine = gumballMachine;
        }
        @Override
        public void insertQuarter() {
            System.out.println("You can't insert another quarter");
        }
        @Override
        public void ejectQuarter() {
            System.out.println("Quarter returned");
            gumballMachine.setState(gumballMachine.getNoQuarterState());
        }
        @Override
        public void turnCrank() {
            System.out.println("You turned...");
            gumballMachine.setState(gumballMachine.getSoldState());
        }
        @Override
        public void dispense() {
            System.out.println("No gumball dispensed");
        }
    }
    public class NoQuarterState implements State {
        GumballMachine gumballMachine;
        public NoQuarterState(GumballMachine gumballMachine) {
            this.gumballMachine = gumballMachine;
        }
        @Override
        public void insertQuarter() {
            System.out.println("You insert a quarter");
            gumballMachine.setState(gumballMachine.getHasQuarterState());
        }
        @Override
        public void ejectQuarter() {
            System.out.println("You haven't insert a quarter");
        }
        @Override
        public void turnCrank() {
            System.out.println("You turned, but there's no quarter");
        }
        @Override
        public void dispense() {
            System.out.println("You need to pay first");
        }
    }
    public class SoldOutState implements State {
        GumballMachine gumballMachine;
        public SoldOutState(GumballMachine gumballMachine) {
            this.gumballMachine = gumballMachine;
        }
        @Override
        public void insertQuarter() {
            System.out.println("You can't insert a quarter, the machine is sold out");
        }
        @Override
        public void ejectQuarter() {
            System.out.println("You can't eject, you haven't inserted a quarter yet");
        }
        @Override
        public void turnCrank() {
            System.out.println("You turned, but there are no gumballs");
        }
        @Override
        public void dispense() {
            System.out.println("No gumball dispensed");
        }
    }
    public class SoldState implements State {
        GumballMachine gumballMachine;
        public SoldState(GumballMachine gumballMachine) {
            this.gumballMachine = gumballMachine;
        }
        @Override
        public void insertQuarter() {
            System.out.println("Please wait, we're already giving you a gumball");
        }
        @Override
        public void ejectQuarter() {
            System.out.println("Sorry, you already turned the crank");
        }
        @Override
        public void turnCrank() {
            System.out.println("Turning twice doesn't get you another gumball!");
        }
        @Override
        public void dispense() {
            gumballMachine.releaseBall();
            if (gumballMachine.getCount() > 0) {
                gumballMachine.setState(gumballMachine.getNoQuarterState());
            } else {
                System.out.println("Oops, out of gumballs");
                gumballMachine.setState(gumballMachine.getSoldOutState());
            }
        }
    }
    public class GumballMachine {
        private State soldOutState;
        private State noQuarterState;
        private State hasQuarterState;
        private State soldState;
        private State state;
        private int count = 0;
        public GumballMachine(int numberGumballs) {
            count = numberGumballs;
            soldOutState = new SoldOutState(this);
            noQuarterState = new NoQuarterState(this);
            hasQuarterState = new HasQuarterState(this);
            soldState = new SoldState(this);
            if (numberGumballs > 0) {
                state = noQuarterState;
            } else {
                state = soldOutState;
            }
        }
        public void insertQuarter() {
            state.insertQuarter();
        }
        public void ejectQuarter() {
            state.ejectQuarter();
        }
        public void turnCrank() {
            state.turnCrank();
            state.dispense();
        }
        public void setState(State state) {
            this.state = state;
        }
        public void releaseBall() {
            System.out.println("A gumball comes rolling out the slot...");
            if (count != 0)
                count -= 1;
        }
        public State getSoldOutState() {
            return soldOutState;
        }
        public State getNoQuarterState() {
            return noQuarterState;
        }
        public State getHasQuarterState() {
            return hasQuarterState;
        }
        public State getSoldState() {
            return soldState;
        }
        public int getCount() {
            return count;
        }
    }
    public class Client {
        public static void main(String[] args) {
            GumballMachine gumballMachine = new GumballMachine(5);
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
            gumballMachine.insertQuarter();
            gumballMachine.ejectQuarter();
            gumballMachine.turnCrank();
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
            gumballMachine.ejectQuarter();
            gumballMachine.insertQuarter();
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
            gumballMachine.insertQuarter();
            gumballMachine.turnCrank();
        }
    }
    // You insert a quarter
    // You turned...
    // A gumball comes rolling out the slot...
    // You insert a quarter
    // Quarter returned
    // You turned, but there's no quarter
    // You need to pay first
    // You insert a quarter
    // You turned...
    // A gumball comes rolling out the slot...
    // You insert a quarter
    // You turned...
    // A gumball comes rolling out the slot...
    // You haven't insert a quarter
    // You insert a quarter
    // You can't insert another quarter
    // You turned...
    // A gumball comes rolling out the slot...
    // You insert a quarter
    // You turned...
    // A gumball comes rolling out the slot...
    // Oops, out of gumballs
    // You can't insert a quarter, the machine is sold out
    // You turned, but there are no gumballs
    // No gumball dispensed
    ```

#### 策略(Strategy)

- 定义: 定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。
- 类图: <div class="align"><img alt="Strategy" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1fc969e4-0e7c-441b-b53c-01950d2f2be5.png"/></div>
    - Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。
    - Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。
- 与状态模式的比较: 状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变Context所组合的State对象，而策略模式是通过Context本身的决策来改变组合的Strategy对象。所谓的状态转移，是指Context在运行过程中由于一些条件发生改变而使得State对象发生改变，注意必须要是在运行过程中(**被动式应答**)。状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么Context对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换Context使用的算法(**主动式应答**)。
- 实现: 设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。
    ```java
    public interface QuackBehavior {
        void quack();
    }
    public class Quack implements QuackBehavior {
        @Override
        public void quack() {
            System.out.println("quack!");
        }
    }
    public class Squeak implements QuackBehavior{
        @Override
        public void quack() {
            System.out.println("squeak!");
        }
    }
    public class Duck {
        private QuackBehavior quackBehavior;
        public void performQuack() {
            if (quackBehavior != null)
                quackBehavior.quack();
        }
        public void setQuackBehavior(QuackBehavior quackBehavior) {
            this.quackBehavior = quackBehavior;
        }
    }
    public class Client {
        public static void main(String[] args) {
            Duck duck = new Duck();
            duck.setQuackBehavior(new Squeak());
            duck.performQuack();    // squeak!
            duck.setQuackBehavior(new Quack());
            duck.performQuack();    // quack!
        }
    }
    ```
- JDK
    - [java.util.Comparator#compare()]()
    - [javax.servlet.http.HttpServlet]()
    - [javax.servlet.Filter#doFilter()]()

#### 模板方法(Template Method)

- 定义: 定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。
- 类图: <div class="align"><img alt="Template Method" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c3c1c0e8-3a78-4426-961f-b46dd0879dd8.png"/></div>
- 实现: 冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。<div class="align"><img alt="Template Method Implemetation" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/11236498-1417-46ce-a1b0-e10054256955.png"/></div>
    ```java
    public abstract class CaffeineBeverage {
        final void prepareRecipe() {
            boilWater();
            brew();
            pourInCup();
            addCondiments();
        }
        abstract void brew();
        abstract void addCondiments();
        void boilWater() {
            System.out.println("boilWater");
        }
        void pourInCup() {
            System.out.println("pourInCup");
        }
    }
    public class Coffee extends CaffeineBeverage {
        @Override
        void brew() {
            System.out.println("Coffee.brew");
        }
        @Override
        void addCondiments() {
            System.out.println("Coffee.addCondiments");
        }
    }
    public class Tea extends CaffeineBeverage {
        @Override
        void brew() {
            System.out.println("Tea.brew");
        }
        @Override
        void addCondiments() {
            System.out.println("Tea.addCondiments");
        }
    }
    public class Client {
        public static void main(String[] args) {
            CaffeineBeverage caffeineBeverage = new Coffee();
            caffeineBeverage.prepareRecipe();
            System.out.println("-----------");
            caffeineBeverage = new Tea();
            caffeineBeverage.prepareRecipe();
            // boilWater
            // Coffee.brew
            // pourInCup
            // Coffee.addCondiments
            // -----------
            // boilWater
            // Tea.brew
            // pourInCup
            // Tea.addCondiments
        }
    }
    ```
- JDK
    - java.util.Collections#sort()
    - java.io.InputStream#skip()
    - java.io.InputStream#read()
    - java.util.AbstractList#indexOf()

#### 访问者(Visitor)

- 定义: 为一个对象结构(比如组合结构)增加新能力。
- 类图: <div class="align"><img alt="Visitor" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/ec923dc7-864c-47b0-a411-1f2c48d084de.png"/></div>
    - Visitor: 访问者，为每一个 ConcreteElement 声明一个 visit 操作
    - ConcreteVisitor: 具体访问者，存储遍历过程中的累计结果
    - ObjectStructure: 对象结构，可以是组合结构，或者是一个集合。
- 实现:
    ```java
    public interface Element {
        void accept(Visitor visitor);
    }
    class CustomerGroup {
        private List<Customer> customers = new ArrayList<>();
        void accept(Visitor visitor) {
            for (Customer customer : customers)
                customer.accept(visitor);
        }
        void addCustomer(Customer customer) {
            customers.add(customer);
        }
    }
    public class Customer implements Element {
        private String name;
        private List<Order> orders = new ArrayList<>();
        Customer(String name) {
            this.name = name;
        }
        String getName() {
            return name;
        }
        void addOrder(Order order) {
            orders.add(order);
        }
        public void accept(Visitor visitor) {
            visitor.visit(this);
            for (Order order : orders)
                order.accept(visitor);
        }
    }
    public class Order implements Element {
        private String name;
        private List<Item> items = new ArrayList();
        Order(String name) {
            this.name = name;
        }
        Order(String name, String itemName) {
            this.name = name;
            this.addItem(new Item(itemName));
        }
        String getName() {
            return name;
        }
        void addItem(Item item) {
            items.add(item);
        }
        public void accept(Visitor visitor) {
            visitor.visit(this);
            for (Item item : items)
                item.accept(visitor);
        }
    }
    public class Item implements Element {
        private String name;
        Item(String name) {
            this.name = name;
        }
        String getName() {
            return name;
        }
        public void accept(Visitor visitor) {
            visitor.visit(this);
        }
    }
    ```
    ```java
    public interface Visitor {
        void visit(Customer customer);
        void visit(Order order);
        void visit(Item item);
    }
    public class GeneralReport implements Visitor {
        private int customersNo;
        private int ordersNo;
        private int itemsNo;
        public void visit(Customer customer) {
            System.out.println(customer.getName());
            customersNo++;
        }
        public void visit(Order order) {
            System.out.println(order.getName());
            ordersNo++;
        }
        public void visit(Item item) {
            System.out.println(item.getName());
            itemsNo++;
        }
        public void displayResults() {
            System.out.println("Number of customers: " + customersNo);
            System.out.println("Number of orders:    " + ordersNo);
            System.out.println("Number of items:     " + itemsNo);
        }
    }
    ```
    ```java
    public class Client {
        public static void main(String[] args) {
            Customer customer1 = new Customer("customer1");
            customer1.addOrder(new Order("order1", "item1"));
            customer1.addOrder(new Order("order2", "item1"));
            customer1.addOrder(new Order("order3", "item1"));
            Order order = new Order("order_a");
            order.addItem(new Item("item_a1"));
            order.addItem(new Item("item_a2"));
            order.addItem(new Item("item_a3"));
            Customer customer2 = new Customer("customer2");
            customer2.addOrder(order);
            CustomerGroup customers = new CustomerGroup();
            customers.addCustomer(customer1);
            customers.addCustomer(customer2);
            GeneralReport visitor = new GeneralReport();
            customers.accept(visitor);
            visitor.displayResults();
        }
    }
    // customer1
    // order1
    // item1
    // order2
    // item1
    // order3
    // item1
    // customer2
    // order_a
    // item_a1
    // item_a2
    // item_a3
    // Number of customers: 2
    // Number of orders:    4
    // Number of items:     6
    ```
- JDK: 
    - javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor
    - javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor

#### 空对象(Null)

- 定义: 使用什么都不做的空对象来代替NULL。一个方法返回NULL，意味着方法的调用端需要去检查返回值是否是NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。
- 类图: <div class="align"><img alt="Null" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/dd3b289c-d90e-44a6-a44c-4880517eb1de.png"/></div>
- 实现: 
    ```java
    public abstract class AbstractOperation {
        abstract void request();
    }
    public class RealOperation extends AbstractOperation {
        @Override
        void request() {
            System.out.println("do something");
        }
    }
    public class NullOperation extends AbstractOperation{
        @Override
        void request() {
            // do nothing
        }
    }
    public class Client {
        public static void main(String[] args) {
            AbstractOperation abstractOperation = func(-1);
            abstractOperation.request();
        }
        public static AbstractOperation func(int para) {
            if (para < 0) {
                return new NullOperation();
            }
            return new RealOperation();
        }
    }
    ```

### 结构型

#### 适配器(Adapter)

- 定义: 把一个类接口转换成另一个用户需要的接口。<div class="align"><img alt="Adapter Define" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"/></div>
- 类图: <div class="align"><img alt="Adapter Class Diagram" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/0889c0b4-07b4-45fc-873c-e0e16b97f67d.png"/></div>
- 实现: 鸭子(Duck)和火鸡(Turkey)拥有不同的叫声，Duck的叫声调用quack()方法，而Turkey调用gobble()方法。要求将Turkey的gobble()方法适配成Duck的quack()方法，从而让火鸡冒充鸭子！
    ```java
    public interface Duck {
        void quack();
    }
    public interface Turkey {
        void gobble();
    }
    public class WildTurkey implements Turkey {
        @Override
        public void gobble() {
            System.out.println("gobble!");
        }
    }
    public class TurkeyAdapter implements Duck {
        Turkey turkey;
        public TurkeyAdapter(Turkey turkey) {
            this.turkey = turkey;
        }
        @Override
        public void quack() {
            turkey.gobble();
        }
    }
    public class Client {
        public static void main(String[] args) {
            Turkey turkey = new WildTurkey();
            Duck duck = new TurkeyAdapter(turkey);
            duck.quack();
        }
    }
    ```
- JDK: 
    - [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29)
    - [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
    - [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
    - [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)

#### 桥接(Bridge)

- 定义: 将抽象与实现分离开来，使它们可以独立变化。
- 类图: <div class="align"><img alt="Bridge" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png"/></div>
    - Abstraction: 定义抽象类的接口
    - Implementor: 定义实现类接口
- 实现: RemoteControl表示遥控器，指代Abstraction。TV表示电视，指代Implementor。桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。
    ```java
    public abstract class TV {
        public abstract void on();
        public abstract void off();
        public abstract void tuneChannel();
    }
    public class Sony extends TV {
        @Override
        public void on() {
            System.out.println("Sony.on()");
        }
        @Override
        public void off() {
            System.out.println("Sony.off()");
        }
        @Override
        public void tuneChannel() {
            System.out.println("Sony.tuneChannel()");
        }
    }
    public class RCA extends TV {
        @Override
        public void on() {
            System.out.println("RCA.on()");
        }
        @Override
        public void off() {
            System.out.println("RCA.off()");
        }
        @Override
        public void tuneChannel() {
            System.out.println("RCA.tuneChannel()");
        }
    }
    public abstract class RemoteControl {
        protected TV tv;
        public RemoteControl(TV tv) {
            this.tv = tv;
        }
        public abstract void on();
        public abstract void off();
        public abstract void tuneChannel();
    }
    public class ConcreteRemoteControl1 extends RemoteControl {
        public ConcreteRemoteControl1(TV tv) {
            super(tv);
        }
        @Override
        public void on() {
            System.out.println("ConcreteRemoteControl1.on()");
            tv.on();
        }
        @Override
        public void off() {
            System.out.println("ConcreteRemoteControl1.off()");
            tv.off();
        }
        @Override
        public void tuneChannel() {
            System.out.println("ConcreteRemoteControl1.tuneChannel()");
            tv.tuneChannel();
        }
    }
    public class ConcreteRemoteControl2 extends RemoteControl {
        public ConcreteRemoteControl2(TV tv) {
            super(tv);
        }
        @Override
        public void on() {
            System.out.println("ConcreteRemoteControl2.on()");
            tv.on();
        }
        @Override
        public void off() {
            System.out.println("ConcreteRemoteControl2.off()");
            tv.off();
        }
        @Override
        public void tuneChannel() {
            System.out.println("ConcreteRemoteControl2.tuneChannel()");
            tv.tuneChannel();
        }
    }
    public class Client {
        public static void main(String[] args) {
            RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());
            remoteControl1.on();
            remoteControl1.off();
            remoteControl1.tuneChannel();
            RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());
            remoteControl2.on();
            remoteControl2.off();
            remoteControl2.tuneChannel();
        }
    }
    ```
- JDK: 
    - AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)
    - JDBC

#### 组合(Composite)

- 定义: 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。
- 类图: <div class="align"><img alt="Composite" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/77931a4b-72ba-4016-827d-84b9a6845a51.png"/></div>组件(Component)类是组合类(Composite)和叶子类(Leaf)的父类，可以把组合类看成是树的中间节点。组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。
- 实现: 
    ```java
    public abstract class Component {
        protected String name;
        public Component(String name) {
            this.name = name;
        }
        public void print() {
            print(0);
        }
        abstract void print(int level);
        abstract public void add(Component component);
        abstract public void remove(Component component);
    }
    public class Composite extends Component {
        private List<Component> child;
        public Composite(String name) {
            super(name);
            child = new ArrayList<>();
        }
        @Override
        void print(int level) {
            for (int i = 0; i < level; i++)
                System.out.print("--");
            System.out.println("Composite:" + name);
            for (Component component : child)
                component.print(level + 1);
        }
        @Override
        public void add(Component component) {
            child.add(component);
        }
        @Override
        public void remove(Component component) {
            child.remove(component);
        }
    }
    public class Leaf extends Component {
        public Leaf(String name) {
            super(name);
        }
        @Override
        void print(int level) {
            for (int i = 0; i < level; i++)
                System.out.print("--");
            System.out.println("left:" + name);
        }
        @Override
        public void add(Component component) {
            throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
        }
        @Override
        public void remove(Component component) {
            throw new UnsupportedOperationException();
        }
    }
    public class Client {
        public static void main(String[] args) {
            Composite root = new Composite("root");
            Component node1 = new Leaf("1");
            Component node2 = new Composite("2");
            Component node3 = new Leaf("3");
            root.add(node1);
            root.add(node2);
            root.add(node3);
            Component node21 = new Leaf("21");
            Component node22 = new Composite("22");
            node2.add(node21);
            node2.add(node22);
            Component node221 = new Leaf("221");
            node22.add(node221);
            root.print();
            // Composite:root
            // --left:1
            // --Composite:2
            // ----left:21
            // ----Composite:22
            // ------left:221
            // --left:3
        }
    }
    ```
- JDK: 
    - javax.swing.JComponent#add(Component)
    - java.awt.Container#add(Component)
    - java.util.Map#putAll(Map)
    - java.util.List#addAll(Collection)
    - java.util.Set#addAll(Collection)

#### 装饰(Decorator)

- 定义: 为对象动态添加功能。
- 类图: <div class="align"><img alt="Decorator" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png"/></div>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。
- 实现: 设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。<br>下图表示在DarkRoast饮料上新增新添加Mocha配料，之后又添加了Whip配料。DarkRoast被Mocha包裹，Mocha又被Whip包裹。它们都继承自相同父类，都有cost()方法，外层类的cost()方法调用了内层类的cost()方法。
    ```java
    public interface Beverage {
        double cost();
    }
    public class DarkRoast implements Beverage {
        @Override
        public double cost() {
            return 1;
        }
    }
    public class HouseBlend implements Beverage {
        @Override
        public double cost() {
            return 1;
        }
    }
    public abstract class CondimentDecorator implements Beverage {
        protected Beverage beverage;
    }
    public class Milk extends CondimentDecorator {
        public Milk(Beverage beverage) {
            this.beverage = beverage;
        }
        @Override
        public double cost() {
            return 1 + beverage.cost();
        }
    }
    public class Mocha extends CondimentDecorator {
        public Mocha(Beverage beverage) {
            this.beverage = beverage;
        }
        @Override
        public double cost() {
            return 1 + beverage.cost();
        }
    }
    public class Client {
        public static void main(String[] args) {
            Beverage beverage = new HouseBlend();
            beverage = new Mocha(beverage);
            beverage = new Milk(beverage);
            System.out.println(beverage.cost());    // 3
        }
    }
    ```
- 设计原则: 类应该**对扩展开放，对修改关闭**: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。
- JDK: 
    - java.io.BufferedInputStream(InputStream)
    - java.io.DataInputStream(InputStream)
    - java.io.BufferedOutputStream(OutputStream)
    - java.util.zip.ZipOutputStream(OutputStream)
    - java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes)

#### 外观/门面(Facade)

- 定义: 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。
- 类图: <div class="align"><img alt="Facade" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"/></div>
- 实现: 观看电影需要操作很多电器，使用外观模式实现一键看电影功能。
    ```java
    public class SubSystem {
        public void turnOnTV() {
            System.out.println("turnOnTV()");
        }
        public void setCD(String cd) {
            System.out.println("setCD( " + cd + " )");
        }
        public void startWatching(){
            System.out.println("startWatching()");
        }
    }
    public class Facade {
        private SubSystem subSystem = new SubSystem();
        public void watchMovie() {
            subSystem.turnOnTV();
            subSystem.setCD("a movie");
            subSystem.startWatching();
        }
    }
    public class Client {
        public static void main(String[] args) {
            Facade facade = new Facade();
            facade.watchMovie();
        }
    }
    ```
- 设计原则: 最少知识原则: 只和你的密友谈话。也就是说**客户对象所需要交互的对象应当尽可能少**。

#### 享元(Flyweight)

- 定义: 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。
    - 在享元模式中可以共享的相同内容称为 **内部状态**(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为 **外部状态**(Extrinsic State)，其中外部状态和内部状态是相互独立的，外部状态的变化不会引起内部状态的变化。由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。
    - 在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个**享元池**(Flyweight Pool)（用于存储具有相同内部状态的享元对象）。在享元模式中，共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为 细粒度对象。 
- 类图: <div class="align"><img alt="Flyweight" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/d52270b4-9097-4667-9f18-f405fc661c99.png"/></div>
    - Flyweight: 享元对象
    - IntrinsicState: 内部状态，享元对象共享内部状态
    - ExtrinsicState: 外部状态，每个享元对象的外部状态不同
    - FlyweightFactory: 享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口
- 模式扩展: 
    - **单纯享元模式**: 在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。
    - **复合享元模式**: 将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。
- 在以下情况下可以使用享元模式：
    - 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；
    - 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中(细粒度对象)；
    - 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。
- 模式的优点
    1. 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份； 
    2. 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。
- 模式的缺点
    1. 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化； 
    2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
- 实现: 
    ```java
    public interface Flyweight {
        void doOperation(String extrinsicState);
    }
    public class ConcreteFlyweight implements Flyweight {
        private String intrinsicState;
        public ConcreteFlyweight(String intrinsicState) {
            this.intrinsicState = intrinsicState;
        }
        @Override
        public void doOperation(String extrinsicState) {
            System.out.println("Object address: " + System.identityHashCode(this));
            System.out.println("IntrinsicState: " + intrinsicState);
            System.out.println("ExtrinsicState: " + extrinsicState);
        }
    }
    public class FlyweightFactory {
        private HashMap<String, Flyweight> flyweights = new HashMap<>();
        Flyweight getFlyweight(String intrinsicState) {
            if (!flyweights.containsKey(intrinsicState)) {
                flyweights.put(intrinsicState, new ConcreteFlyweight(intrinsicState));
            }
            return flyweights.get(intrinsicState);
        }
    }
    public class Client {
        public static void main(String[] args) {
            FlyweightFactory factory = new FlyweightFactory();
            Flyweight flyweight1 = factory.getFlyweight("aa");
            Flyweight flyweight2 = factory.getFlyweight("aa");
            flyweight1.doOperation("x");
            flyweight2.doOperation("y");
        }
        // Object address: 1163157884
        // IntrinsicState: aa
        // ExtrinsicState: x
        // Object address: 1163157884
        // IntrinsicState: aa
        // ExtrinsicState: y
    }
    ```
- JDK: Java 利用缓存来加速大量小对象的访问时间。
    - java.lang.Integer#valueOf(int)
    - java.lang.Boolean#valueOf(boolean)
    - java.lang.Byte#valueOf(byte)
    - java.lang.Character#valueOf(char)

#### 代理(Proxy)

- 定义: 控制对其它对象的访问。拦截、处理外界的信息。
    - **静态代理**: 需要我们编码时就确定代理、被代理对象关系，如果有大量的或者运行时才确定的代理行为，静态代理就不太合适了；
    - **动态代理**: 使用反射，通过参数和代理方法自动生成代理的代码。
- 类图: <div class="align"><img alt="Proxy" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/a6c20f60-5eba-427d-9413-352ada4b40fe.png"/></div>
    代理有以下四类: 
    - 远程代理(Remote Proxy): 控制对远程对象(不同地址空间)的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
    - 虚拟代理(Virtual Proxy): 根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
    - 保护代理(Protection Proxy): 按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
    - 智能代理(Smart Reference): 取代了简单的指针，它在访问对象时执行一些附加操作: 记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。
- 实现: 以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。
    ```java
    public interface Image {
        void showImage();
    }
    public class HighResolutionImage implements Image {
        private URL imageURL;
        private long startTime;
        private int height;
        private int width;
        public int getHeight() {
            return height;
        }
        public int getWidth() {
            return width;
        }
        public HighResolutionImage(URL imageURL) {
            this.imageURL = imageURL;
            this.startTime = System.currentTimeMillis();
            this.width = 600;
            this.height = 600;
        }
        public boolean isLoad() {
            // 模拟图片加载，延迟 3s 加载完成
            long endTime = System.currentTimeMillis();
            return endTime - startTime > 3000;
        }
        @Override
        public void showImage() {
            System.out.println("Real Image: " + imageURL);
        }
    }
    public class ImageProxy implements Image {
        private HighResolutionImage highResolutionImage;
        public ImageProxy(HighResolutionImage highResolutionImage) {
            this.highResolutionImage = highResolutionImage;
        }
        @Override
        public void showImage() {
            while (!highResolutionImage.isLoad()) {
                try {
                    System.out.println("Temp Image: " + highResolutionImage.getWidth() + " " + highResolutionImage.getHeight());
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            highResolutionImage.showImage();
        }
    }
    public class ImageViewer {
        public static void main(String[] args) throws Exception {
            String image = "http://image.jpg";
            URL url = new URL(image);
            HighResolutionImage highResolutionImage = new HighResolutionImage(url);
            ImageProxy imageProxy = new ImageProxy(highResolutionImage);
            imageProxy.showImage();
        }
    }
    ```
- JDK: 
    - java.lang.reflect.Proxy
    - RMI

### 六大原则

#### 单一责任原则(Single Responsibility Principle, SRP)

**一个类只负责一个功能领域中的相应职责，或者可以定义为: 就一个类而言，应该只有一个引起它变化的原因。**

在软件系统中，一个类(大到模块，小到方法)承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

单一职责原则是实现**高内聚、低耦合**的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。

#### 开闭原则(Open-Closed Principle, OCP)

**一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。**

在开闭原则的定义中，**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类**。

任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。

为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键**。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

注意: 因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，**一般不把对配置文件的修改认为是对系统源代码的修改**。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。

#### 里氏替换原则(Liskov Substitution Principle, LSP)

**如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。**或者说: **所有引用基类(父类)的地方必须能透明地使用其子类的对象**。

里氏代换原则告诉我们，**在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象**。例如: 我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

里氏代换原则是实现开闭原则的重要方式之一，**由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。

在使用里氏代换原则时需要注意如下几个问题: 

1. 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
2. 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。
3. Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。

#### 依赖倒置原则(Dependency Inversion Principle, DIP)

**抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**

**依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。**

在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。

在实现依赖倒转原则时，我们需要针**对抽象层编程**，而将具体类的对象通过**依赖注入(DependencyInjection, DI)**的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是: **构造注入，设值注入(Setter注入)和接口注入**。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

在大多数情况下，这前面三设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。

#### 接口隔离原则(Interface Segregation Principle, ISP)

**使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。**

根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。**每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干**。这里的“接口”往往有两种不同的含义: 一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同: 

1. 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。
2. 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。

**在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便**。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

#### 迪米特法则(Law of Demeter, LoD)

**一个软件实体应当尽可能少地与其他实体发生相互作用**。迪米特法则又称为**最少知识原则(LeastKnowledge Principle, LKP)**。

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。**迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系**。

迪米特法则还有几种定义形式，包括: 不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类: 

1. 当前对象本身(this)；
2. 以参数形式传入到当前对象方法中的对象；
3. 当前对象的成员对象；
4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
5. 当前对象所创建的对象。

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。

迪米特法则要求我们在设计系统时，**应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用**。简言之，就是**通过引入一个合理的第三者来降低现有对象之间的耦合度**。

在将迪米特法则运用到系统设计中时，要注意下面的几点: **在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低**。

### end

```html
<div class="align"><img alt="" src=""/></div>

- 定义: 
- 类图: <div class="align"><img alt="" src=""/></div>
- 实现: 
- JDK: 
```

- 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.
- Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.
- Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.
- [Design Patterns](http://www.oodesign.com/)
- [Design patterns implemented in Java](http://java-design-patterns.com/)
- [The breakdown of design patterns in JDK](http://www.programering.com/a/MTNxAzMwATY.html)

