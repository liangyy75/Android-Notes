1. 简单说一说drop、delete与truncate的区别: SQL中的drop、delete、truncate都表示删除，但是三者有一些差别
    1. delete和truncate只删除表的数据不删除表的结构
    2. 速度，一般来说: drop> truncate >delete
    3. delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效；如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.
2. drop、delete与truncate分别在什么场景之下使用？
    1. 不再需要一张表的时候，用drop
    2. 想删除部分数据行时候，用delete，并且带上where子句
    3. 保留表而删除所有数据的时候用truncate
3. 超键、候选键、主键、外键分别是什么？
    1. 超键: 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
    2. 候选键: 是最小超键，即没有冗余元素的超键。
    3. 主键: 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值(Null)。
    4. 外键: 在一个表中存在的另一个表的主键称此表的外键。
4. **什么是视图？以及视图的使用场景有哪些？**
    1. 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
    2. 只暴露部分字段给访问者，所以就建一个虚表，就是视图。
    3. 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异
5. 索引失效的场景: 
    1. null
    2. is null/ is not null/ <>/ != 等无法比较操作
    3. 多条件 or
    4. 索引列使用在了函数或者运算中
    5. 查询范围过大
    6. 使用了like，且不相当于前缀索引
6. **sql书写技巧**
    1. 用exists、in代替distinct: distinct实际上是先收集再删除这样两步都耗资源，exists,in会隐式过滤掉重复的记录
    2. 合并sql语句: 可以把很多功能相似的sql语句，合并为一条，以达到减少系统资源开销的目的
    3. 调整join操作顺序: join操作是自顶向下的，多表关联时，应把可以快速减少记录的关联表放在前面进行关联
    4. 负向查询改为正向查询: not in 导致不能使用到索引，应修改为正逻辑left join 后来筛选
7. 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？
    1. B+tree的磁盘读写代价更低
    2. B+tree的查询效率更加稳定
    3. B+tree支持区间查询
8. 文件索引和数据库索引为什么使用B+树?
    - 文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处: 方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。
9. 索引的优点/缺点
    1. 大大加快数据的检索速度，这也是创建索引的最主要的原因；
    2. 加速表和表之间的连接；
    3. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
    4. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
    1. 时间方面: 创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
    2. 空间方面: 索引需要占物理空间。
10. 什么样的字段适合创建索引？
    1. 经常作查询选择的字段
    2. 经常作表连接的字段
    3. 经常出现在order by, group by, distinct 后面的字段
    4. 区分度高的字段
11. 创建索引时需要注意什么？
    1. 非空字段: 应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
    2. 取值离散大的字段: (变量各个取值之间的差异程度)的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
    3. 索引字段越小越好: 数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
12. 主键、自增主键、主键索引与唯一索引概念区别
    1. 主键: 指字段 唯一、不为空值 的列；
    2. 主键索引: 指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；
    3. 自增主键: 字段类型为数字、自增、并且是主键；
    4. 唯一索引: 索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。
13. **主键就是聚集索引吗？主键和索引有什么区别？**
    - 主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。
14. SQL语句的优化: 
    1. 如何发现有问题的SQL
        - 通过MySQL慢查询日志对有效率问题的SQL进行监控。MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。
        - 通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。
    2. 如何分析SQL的执行计划
        - 通过explain查询和分析SQL的执行计划: 使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。
    3. **如何优化SQL**: 
        1. 优化insert语句: 一次插入多值；
        2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
        3. 应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；
        4. 优化嵌套查询: 子查询可以被更有效率的连接(Join)替代；
        5. 很多时候用 exists 代替 in 是一个好的选择。
15. 数据库表结构的优化: 包括选择合适数据类型、表的范式的优化、表的垂直拆分和表的水平拆分等手段。
    1. 选择合适数据类型
        1. 使用较小的数据类型解决问题；
        2. 使用简单的数据类型(mysql处理int要比varchar容易)；
        3. 尽可能的使用 not null 定义字段；
        4. 尽量避免使用 text 类型，非用不可时最好考虑分表；
    2. 表的范式的优化: 一般情况下，表的设计应该遵循三大范式。
    3. 表的垂直拆分
        1. 把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段: 
        2. 把不常用的字段单独放在同一个表中；
        3. 把大字段独立放入一个表中；
        4. 把经常使用的字段放在一起； 
        5. 这样做的好处是非常明显的，具体包括: 拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单。
    4. 表的水平拆分
        1. 表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种: 
        2. 对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；
        3. 针对不同的hashID将数据存入不同的表中；
16. 系统配置的优化
    1. 操作系统配置的优化: 增加TCP支持的队列数
    2. mysql配置文件优化: Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数(innodb_buffer_pool_instances)
17. 硬件的优化
    1. CPU: 核心数多并且主频高的
    2. 内存: 增大内存
    3. 磁盘配置和选择: 磁盘性能
18. **什么是存储过程？有哪些优缺点？** https://blog.csdn.net/luyaran/column/info/24915
    1. 存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。进一步地说，存储过程是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能(对单表或多表的增删改查)，然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。存储过程具有以下特点: 
    2. 存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率；
    3. 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码；
    4. 减少网络传输，在客户端调用一个存储过程当然比执行一串SQL传输的数据量要小；
    5. 通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。
19. **什么叫视图？游标是什么？**
    1. 视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增，删，改，查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。
    2. 游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
    3. 在操作mysql的时候，我们知道MySQL检索操作返回一组称为结果集的行。这组返回的行都是与 SQL语句相匹配的行(零行或多行)。使用简单的 SELECT语句，例如，没有办法得到第一行、下一行或前 10行，也不存在每次一行地处理所有行的简单方法(相对于成批地处理它们)。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标(cursor)是一个存储在MySQL服务器上的数据库查询，它不是一条 SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。
20. **什么是触发器？**触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。
21. **MySQL存储引擎中的MyISAM和InnoDB区别详解**
    1. 在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM(Indexed Sequential Access Method: 有索引的顺序访问方法)所改良。虽然MyISAM性能极佳，但却有一个显著的缺点:  不支持事务处理。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。
    2. InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，InnoDB的最大特色就是支持ACID兼容的事务功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括: 
    3. 通过下面的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。
    1. 存储结构: 每个MyISAM在磁盘上存储成三个文件: 第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中(也可能是多个文件，或者是独立的表空间文件)，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
    2. 存储空间: MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
    3. 可移植性、备份及恢复: MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。
    4. 事务支持: MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。
    5. AUTO_INCREMENT: 在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
    6. 表锁差异: MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
    7. 全文索引: myisam支持 fulltext类型的全文索引；innodb不支持fulltext类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
    8. 表主键: MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
    9. 表的具体行数: MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
    10. CURD操作: 在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。
    11. 外键: MyISAM不支持外键，而InnoDB支持外键。
22. **JDBC对事务的支持**
    1. 对于JDBC而言，每条单独的语句都是一个事务，即每个语句后都隐含一个commit。实际上，Connection 提供了一个auto-commit的属性来指定事务何时结束。当auto-commit为true时，当每个独立SQL操作的执行完毕，事务立即自动提交，也就是说，每个SQL操作都是一个事务；当auto-commit为false时，每个事务都必须显式调用commit方法进行提交，或者显式调用rollback方法进行回滚。auto-commit默认为true。
    2. 
    ```java
    try {  
        conn.setAutoCommit(false);  //将自动提交设置为false        
        ps.executeUpdate("修改SQL"); //执行修改操作  
        ps.executeQuery("查询SQL");  //执行查询操作                 
        conn.commit();      //当两个操作成功后手动提交     
    } catch (Exception e) {  
        conn.rollback();    //一旦其中一个操作出错都将回滚，使两个操作都不成功  
        e.printStackTrace();  
    }
    ```
    3. 为了能够将多条SQL当成一个事务执行，必须首先通过Connection关闭auto-commit模式，然后通过Connection的setTransactionIsolation()方法设置事务的隔离级别，最后分别通过Connection的commit()方法和rollback()方法来提交事务和回滚事务。
23. **MySQL中的悲观锁与乐观锁的实现**
    1. 悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。通常来讲，在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select … for update时会获取被select中的数据行的行锁，因此其他并发执行的select … for update如果试图选中同一行则会发生排斥(需要等待行锁被释放)，因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。<br>
    这里需要特别注意的是，不同的数据库对select… for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外，mysql还有个问题是: select… for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此，如果在mysql中用悲观锁务必要确定使用了索引，而不是全表扫描。
    2. 乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现: 
        ```sql
        1. select data as old_data, version as old_version from …;
        2. 根据获取的数据进行业务操作，得到new_data和new_version
        3. update set data = new_data, version = new_version where version = old_version
        if (updated row > 0) {
            // 乐观锁获取成功，操作完成
        } else {
            // 乐观锁获取失败，回滚并重试
        }
        ```
        乐观锁是否在事务中其实都是无所谓的，其底层机制是这样: 在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这其间没有发生并发的修改。如果更新失败，即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。
    3. 悲观锁与乐观锁的应用场景: 一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。
24. **要创建可更新视图，定义视图的select语句不能包含以下任何元素**: 
    - 聚合函数，如: min，max，sum，avg，count等。
    - distinct子句
    - group by子句
    - having子句
    - 左连接或外连接。
    - union或union all子句
    - select子句中的子查询或引用该表的where子句中的子查询出现在from子句中。
    - 引用from子句中的不可更新视图
    - 仅引用文字值
    - 对基表的任何列的多次引用
24. **MySQL各存储引擎使用了三种类型(级别)的锁定机制: 表级锁定，行级锁定和页级锁定。**: 
    1. **表级锁定(table-level)**: 表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。
    2. **行级锁定(row-level)**: 行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。使用行级锁定的主要是InnoDB存储引擎。
    3. **页级锁定(page-level)**: 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。使用页级锁定的主要是BerkeleyDB存储引擎。
    4. 总的来说，MySQL这3种锁的特性可大致归纳如下: 
        1. 表级锁: 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
        2. 行级锁: 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
        3. 页面锁: 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
        4. 适用: 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
25. **sql触发器的优点、缺点与限制**: https://blog.csdn.net/luyaran/column/info/24940 检测数据 检测错误 日志 只能提供部分验证 对用户不可见 增加开销
    1. 提供了检查数据完整性的替代方法。
    2. 可以捕获数据库层中业务逻辑中的错误。
    3. 提供了运行计划任务的另一种方法。通过使用SQL触发器，您不必等待运行计划的任务，因为在对表中的数据进行更改之前或之后自动调用触发器。
    4. 对于审核表中数据的更改非常有用。
    1. 只能提供扩展验证，并且无法替换所有验证。一些简单的验证必须在应用层完成。例如，您可以使用JavaScript或服务器端使用服务器端脚本语言(如JSP，PHP，ASP.NET，Perl等)来验证客户端的用户输入。
    2. 从客户端应用程序调用和执行SQL触发器不可见，因此很难弄清数据库层中发生的情况。
    3. 可能会增加数据库服务器的开销。
    - 使用在SHOW，LOAD DATA，LOAD TABLE，BACKUP DATABASE，RESTORE，FLUSH和RETURN语句之上。
    - 使用隐式或明确提交或回滚的语句，如COMMIT，ROLLBACK，START TRANSACTION，LOCK/UNLOCK TABLES，ALTER，CREATE，DROP，RENAME等。
    - 使用准备语句，如PREPARE，EXECUTE等
    - 使用动态SQL语句。
26. **sql存储过程的优点、缺点与限制**: https://blog.csdn.net/luyaran/column/info/24915 提高性能 减少网络间命令传输的流量 可重用和透明的 安全的 | 大量过程与大量逻辑操作需要内存、CPU 难以调试 难以构造复杂的过程 难以开发与维护
    1. 通常存储过程有助于提高应用程序的性能。当创建，存储过程被编译之后，就存储在数据库中。但是，MySQL实现的存储过程略有不同。MySQL存储过程按需编译。在编译存储过程之后，MySQL将其放入缓存中。 MySQL为每个连接维护自己的存储过程高速缓存。 如果应用程序在单个连接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询。
    2. 存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的SQL语句，而只能发送存储过程的名称和参数。
    3. 存储的程序对任何应用程序都是可重用的和透明的。存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存储过程中已支持的功能。
    4. 存储的程序是安全的。 数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何权限。
    - 如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用大量逻辑操作，则CPU使用率也会增加，因为数据库服务器的设计不当于逻辑运算。
    - 存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难。
    - 很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。
    - 开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能会导致应用程序开发和维护阶段的问题。
27. **T-SQL概述**: DDL DML DCL 附加语言元素
    SQL Server用于操作数据库的编程语言为Transaction-SQL，简称T-SQL。T-SQL与PL/SQL不同，并没有固定的程序结构。在T-SQL中，命令和语句的书写是不区分大小写的。T-SQL包括以下4个部分: 
    - DDL: 定义和管理数据库及其对象，例如create、alter和drop等。
    - DML: 实现对数据库表各对象的操作，例如insert、update等。
    - DCL: 数据控制语言，实现对数据库进行安全管理和权限管理等控制，例如grant、revoke、deny等。
    - 附加的语言元素。T-SQL的附加语言元素，包括变量、运算符、函数、注释和流程控制语句等。
28. **优化查询**
    1. 谨慎使用union，可以使用union all
    2. 谨慎使用distinct，多字段时效率低下
    3. 不要多余的行与列
    4. 尽量契合最左前缀匹配，尽量使用索引，而不要使得索引失效(不要null，<>，!=，is null或者is not null，甚至是将索引列放在了函数或者表达式中)
    5. 尽量使用information_schema.tables获得table_rows，而不是count
    6. 尽量使用区分度高的列作为索引，尽量使用容易比较的字段作为索引，尽量让索引的类型字节小，提高查询效率。
    7. 谨慎使用连接
    8. 尽量使用exists或者between代替in
    9. 尽量使用distinct代替group by
    10. 尽量不要用select into语句。select into 语句会导致表锁定，阻止其他用户访问该表。
    11. 分解大查询，
    12. 分解多表查询
    13. 使用连接代替低效率的子查询
29. **优化插入**
    1. 大数据量的多次插入可以连接起来。
    2. 不要建立过多索引
30. **优化修改删除**
    1. 同时修改或删除过多数据，会造成cpu利用率过高从而影响别人对数据库的访问。
    2. 删除或修改过多数据，采用单一循环操作，那么会是效率很低，也就是操作时间过程会很漫长。
    3. 折中的办法就是，分批操作数据。
        ```sql
        delete product where id<1000
        delete product where id>=1000 and id<2000
        delete product where id>=2000 and id<3000
        .....
        ```
    4. 不要建立过多索引

https://www.cnblogs.com/geaozhang/category/1326927.html  -- sql奇妙物语
https://www.w3cschool.cn/t_sql/  -- t-sql教程
https://www.cnblogs.com/jiangxiaobo/category/788873.html  -- sql奇妙物语
https://blog.csdn.net/shenchaohao12321/article/category/8075653/4  -- MySql技术内幕
https://www.cnblogs.com/knowledgesea/p/3686105.html  -- sql优化