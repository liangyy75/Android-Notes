- **事务**: 满足ACID特性的一组操作，可以Commit，可以Rollback
    - **ACID**: Automatic(原子性) Consistency(一致性) Isolation(隔离性) Durability(持久性)
        - 原子性: 事务不可切割，要么全部成功，要么全部失败
        - 一致性: 事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的
        - 隔离性: 事务所做的修改在最终提交以前，对其它事务是不可见的
        - 持久性: 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。
    - 关系:
        - 满足一致性，事务执行结果才正确
        - 无并发时，事务串行执行，隔离性一定满足，此时只要能满足原子性，就一定能满足一致性
        - 并发时，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性
        - 事务满足持久化是为了能应对数据库崩溃的情况
- **并发一致性问题**: 
    - 丢失修改: T1先改，T2随后改，覆盖了T1的修改
    - 读脏数据: T1改，T2读，T1撤销，T2读到脏数据
    - 不可重复读: T2读，T1改，T2在读，T2两次读不一样
    - 幻读: T1读范围数据，T2插入新数据，T1再读，T1两次读不一样
- 封锁:
    - **封锁粒度**: MySQL中提供了两种封锁粒度: 行级锁以及表级锁；应该尽量只锁定需要修改的那部分数据，而不是所有的资源
    - **封锁类型**:
        - 读写锁: 排它锁(Exclusive X锁 写锁) 共享锁(Shared S锁 读锁)
        - 意向锁: IX/IS(表锁)
    - **封锁协议**: 三级封锁协议与两段封锁协议
        - 一级封锁协议: 事务 T 要**修改**数据 A 时必须**加 X 锁，直到事务 T 结束才释放**锁。可以解决丢失修改问题
        - 二级封锁协议: 在一级的基础上，要求**读取**数据 A 时必须**加 S 锁，读取完马上释放** S 锁。可以解决读脏数据问题
        - 三级封锁协议: 在二级的基础上，要求**读取**数据 A 时必须**加 S 锁，直到事务结束了**才能释放 S 锁。可以解决不可重复读的问题
        - 两段锁协议: 加锁和解锁分为两个阶段进行。事务遵循两段锁协议是保证可串行化调度的充分条件。但不是必要条件
- **隔离级别**: 
    - 未提交读(READ UNCOMMITTED): 事务中的修改，即使没有提交，对其它事务也是可见的。
    - 提交读(READ COMMITTED): 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
    - 可重复读(REPEATABLE READ): 保证在同一个事务中多次读取同样数据的结果是一样的。
    - 可串行化(SERIALIZABLE): 强制事务串行执行。
- **多版本并发控制**: 
    1. select: 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，
    而不用和其它事务的读取结果一致。<br>把没有对一个数据行做修改的事务称为 t，t 所要读取的数据行快照的创建版本号必须小于 t 的版本号，因为如果大于或者等于 t 的版本号，
    那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，t 所要读取的数据行快照的删除版本号必须大于 t 的版本号，因为如果小于等于 t 的版本号，
    那么表示该数据行快照是已经被删除的，不应该去读取它。
    2. insert: 将当前系统版本号作为数据行快照的创建版本号。
    3. delete: 将当前系统版本号作为数据行快照的删除版本号。
    4. update: 将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 delete 后执行 insert。
- **next-key locks**: 
    - ***record locks***: 锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，innodb 会自动在主键上创建隐藏的聚簇索引，因此 record locks 依然可以使用。
    - ***gap locks***: 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
        ```mysql
        select c from t where c between 10 and 20 for update;
        ```
    - ***next-key locks***: 它是 record locks 和 gap locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值: 10, 11, 13, and 20，
        那么就需要锁定以下区间: 
        ```mysql
        (negative infinity, 10]
        (10, 11]
        (11, 13]
        (13, 20]
        (20, positive infinity)
        ```
- **关系型数据库设计理论**: [函数依赖与关系模式分解的一些技巧整理](https://blog.csdn.net/devillyd2018/article/details/79122477)
    1. 函数依赖: 平凡 非平凡 完全 部分 传递 候选码 主键 函数依赖集 多值
    2. 关系分解: 无损分解 有损分解 保持函数依赖 寄生元组 悬挂元组 数据等价 依赖等价 优点与缺点 无损分解的测试方法 
    3. 异常: 冗余数据 修改异常 插入异常 删除异常
    4. 范式:
        1. 第一范式(关系模式R中每一个分量是不可分的数据项)
        2. 第二范式(符合1NF，且每一个非主属性完全函数依赖于码)
        3. 第三范式(符合2NF，且消除传递依赖)
        4. BC范式(符合3NF，且主属性不依赖于主属性(若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式))
            1. 所有非主属性都完全函数依赖于每个候选码
            2. 所有主属性都完全函数依赖于每个不包含于他的候选码
            3. 没有任何属性完全函数依赖于非码的任何一组属性
        5. 第四范式(同一表内的多对多关系删除)
        6. 第五范式(从最终结构重新建立原始结构)
        7. [BCNF范式（修正的第三范式）、第四范式和第五范式](https://blog.csdn.net/g_beginner/article/details/6789308)
    5. 关系代数: 并u 差- 笛卡尔积X 投影π 选择σ; 交n 连接 除
- ER图: 
    1. 实体(在ER图中用矩形表示) 属性(椭圆形) 联系(1联系(1:1) N联系(1:N) M:N联系)
    2. 。。。

[TOC]

事务ACID特效: Atomicity Consistency Isolation Durability<br>
并发一致性问题: 丢失修改 读脏数据 不可重复读 幻影读<br>
封锁粒度: 行级锁与表级锁； 封锁类型: 读写锁(Exclusive Shared)与意向锁； 封锁协议: 三级封锁协议与两段封锁协议<br>
隔离级别: 未提交读(read uncommited) 提交读(read commited) 可重复读(repeatable read) 可串行化(serializable)
***多版本并发控制***: <br>
***Next-Key Locks***: <br>
***关系数据库设计理论***: <br>
***ER图***: <br>

### 基础

#### 事务

1. 概念: 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
    <!-- ![事务](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/731a5e8f-a2c2-43ff-b8dd-6aeb9fffbe26.jpg) -->
    <div align="center"><img alt="事务" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/731a5e8f-a2c2-43ff-b8dd-6aeb9fffbe26.jpg"></div>
2. ACID: 
    1. 原子性(Atomicity): 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
        回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
    2. 一致性(Consistency): 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
    3. 隔离性(Isolation): 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
    4. 持久性(Durability): 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。
3. AUTOCOMMIT: MySQL 默认采用自动提交模式。也就是说，如果不显式使用 START TRANSACTION 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。
4. 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系: 
    - 只有满足一致性，事务的执行结果才是正确的。
    - 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
    - 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
    - 事务满足持久化是为了能应对数据库崩溃的情况。
    <!-- ![ACID](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8036ba3d-8de9-44aa-bf5d-1f8ca18ae89b.jpg) -->
    <div align="center"><img alt="ACID" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8036ba3d-8de9-44aa-bf5d-1f8ca18ae89b.jpg"></div>

#### 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

- 丢失修改: T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。<br>
    <!-- ![丢失修改](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg) -->
    <div align="center"><img alt="丢失修改" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg"></div>
- 读脏数据: T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。<br>
    <!-- ![读脏数据](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bab0fba6-38e4-45f7-b34d-3edaad43810f.jpg) -->
    <div align="center"><img alt="读脏数据" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/bab0fba6-38e4-45f7-b34d-3edaad43810f.jpg"></div>
- 不可重复读: T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br>
    <!-- ![不可重复读](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/43bf0957-0386-4c09-9ad7-e163c5b62559.jpg) -->
    <div align="center"><img alt="不可重复读" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/43bf0957-0386-4c09-9ad7-e163c5b62559.jpg"></div>
- 幻影读: T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br>
    <!-- ![幻影读](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg) -->
    <div align="center"><img alt="幻影读" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg"></div>

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，
相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

#### 封锁

##### 封锁粒度

MySQL 中提供了两种封锁粒度: 行级锁以及表级锁。<br>
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。<br>
但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。<br>
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。<br>
<!-- ![封锁粒度](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg) -->
<div align="center"><img alt="封锁粒度" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg"></div>

##### 封锁类型

1. 读写锁
    - 排它锁(Exclusive)，简写为 X 锁，又称写锁。
    - 共享锁(Shared)，简写为 S 锁，又称读锁。

    有以下两个规定: 

    - 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
    - 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

    锁的兼容关系如下: 

    | - | X | S |
    | - | - | - |
    | X | × | × |
    | S | × | √ |

2. 意向锁: 使用意向锁(Intention Locks)可以更容易地支持多粒度封锁。<br>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，
    就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br>
    意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定: 

    - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
    - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

    通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，
    因此事务 T 加 X 锁失败。

    各种锁的兼容关系如下: 

    - | X | IX | S | IS
    :- |:- |:- |:- |:-
    X | × | × | × | ×
    IX | × | √ | × | √
    S | × | × | √ | √
    IS | × | √ | √ | √

    解释如下: 

    - 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；
    - S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

##### 封锁协议

1. 三级封锁协议<br>
    ***一级封锁协议***<br>
    事务 T 要**修改**数据 A 时必须**加 X 锁，直到事务 T 结束才释放**锁。可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

    T1 | T2
    :- |:-
    lock-x(A) | .
    read A=20 | .
    . | lock-x(A)
    . | wait
    write A=19 | .
    commit | .
    unlock-x(A) | .
    . | obtain
    . | read A=19
    . | write A=21
    . | commit
    . | unlock-x(A)

    ***二级封锁协议***<br>
    在一级的基础上，要求**读取**数据 A 时必须**加 S 锁，读取完马上释放** S 锁。可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，
    会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

    T1 | T2
    :- |:-
    lock-x(A) | .
    read A=20 | .
    write A=19 | .
    . | lock-s(A)
    . | wait
    rollback | .
    A=20 | .
    unlock-x(A) | .
    . | obtain
    . | read A=20
    . | unlock-s(A)
    . | commit

    ***三级封锁协议***<br>
    在二级的基础上，要求**读取**数据 A 时必须**加 S 锁，直到事务结束了**才能释放 S 锁。可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，
    从而避免了在读的期间数据发生改变。

    T1 | T2
    :- |:-
    lock-s(A) | .
    read A=20 | .
    . | lock-x(A)
    . | wait
    read A=20 | .
    commit | .
    unlock-s(A) | .
    . | obtain
    . | read A=20
    . | write A=19
    . | commit
    . | unlock-X(A)

2. 两段锁协议<br>
    加锁和解锁分为两个阶段进行。<br>
    可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。<br>
    事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。
    ```mysql
    lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
    ```
    但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。
    ```mysql
    lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
    ```
    ***MySQL 隐式与显示锁定***<br>
    MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。<br>
    InnoDB 也可以使用特定的语句进行显示锁定: 
    ```mysql
    SELECT ... LOCK In SHARE MODE;
    SELECT ... FOR UPDATE;
    ```

#### 隔离级别

- 未提交读(READ UNCOMMITTED): 事务中的修改，即使没有提交，对其它事务也是可见的。
- 提交读(READ COMMITTED): 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- 可重复读(REPEATABLE READ): 保证在同一个事务中多次读取同样数据的结果是一样的。
- 可串行化(SERIALIZABLE): 强制事务串行执行。

√表示未解决，×表示已解决

隔离级别 | 脏读 | 不可重复读 | 幻影读 | 加锁读
:- |:- |:- |:- |:-
未提交读 | √ | √ | √ | ×
提交读 | × | √ | √ | ×
可重复读 | × | × | √ | ×
可串行化 | × | × | × | √

#### 多版本并发控制

多版本并发控制(Multi-Version Concurrency Control, ***MVCC***)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC 。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

***版本号***

- 系统版本号: 是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号: 事务开始时的系统版本号。

***隐藏的列***

- MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号: 
- 创建版本号: 指示创建一个数据行的快照时的系统版本号；
- 删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

***Undo日志***

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。<br>
<!-- ![Undo日志](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg) -->
<div align="center"><img alt="Undo日志" src="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/pics/e41405a8-7c05-4f70-8092-e961e28d3112.jpg"></div>

***实现过程***

以下实现过程针对可重复读隔离级别。当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。

1. SELECT: 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，
    而不用和其它事务的读取结果一致。<br>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，
    那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，
    那么表示该数据行快照是已经被删除的，不应该去读取它。
2. INSERT: 将当前系统版本号作为数据行快照的创建版本号。
3. DELETE: 将当前系统版本号作为数据行快照的删除版本号。
4. UPDATE: 将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

***快照读与当前读***

1. 快照读: 使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。
    ```mysql
    select * from table ...;
    ```
2. 当前读: 读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。
    ```mysql
    select * from table where ? lock in share mode;
    select * from table where ? for update;
    insert;
    update;
    delete;
    ```

#### Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。<br>
MVCC 不能解决幻读的问题， Next-Key Locks 就是为了解决这个问题而存在的。在可重复读(REPEATABLE READ)隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

- ***Record Locks***: 锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。
- ***Gap Locks***: 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
    ```mysql
    SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
    ```
- ***Next-Key Locks***: 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值: 10, 11, 13, and 20，
    那么就需要锁定以下区间: 
    ```mysql
    (negative infinity, 10]
    (10, 11]
    (11, 13]
    (13, 20]
    (20, positive infinity)
    ```

#### 关系数据库设计理论

1. ***函数依赖***
    1. 函数依赖: 设R(U)是属性集U上的关系模式。X,Y是U的子集，若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或者Y函数依赖与X，记作: X→Y。
    2. 平凡的函数依赖: 如果X→Y，但Y∈X，则称X→Y是平凡的函数依赖
    3. 非平凡的函数依赖: 如果X→Y，但Y∉X，则称X→Y是非平凡的函数依赖。通常情况下总是讨论非平凡的函数依赖
    4. 完全函数依赖: 在R(U)中，如果X→Y，并且对于x的任何一个真子集X'，都有X´不能决定Y，则称Y对X完全函数依赖，记作: X-f->Y(f即full)
    5. 部分函数依赖: 在R(U)中，如果X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作: X-p->Y(p即part)部分函数依赖也称为局部函数依赖
    6. **传递依赖**: 在R(U,F)中，如果X→Y，Y∉X，Y→Z，Y不完全函数依赖于X，则称Z对X传递依赖
    7. 候选码: 设K为R(U,F)中属性的组合，若K-f->U，且对于K的任何一个真子集K'，都有K'不能决定U，则K为R的候选码(候选关键字)。若有多个候选码，则选其中一个作为主码(主键)，包含在任何一个候选码中的属性称之为主属性，反之称之为非主属性。
    8. 设F是关系模式R的一个函数依赖集，X,Y是R的属性子集，如果从F中的函数依赖能够推出X→Y，则称F逻辑蕴含X→Y，记为F|=X→Y。
    9. 设F是函数依赖集，被F逻辑蕴含的函数依赖的全体构成的集合，称为F的闭包，记作F+。F+={X→Y| F|=X→Y}
    10. 设有关系模式R(A1，A2，A3...An)和属性集U=A1，A2，...An,X,Y,Z,W是U的一个子集，F是R德的一个函数依赖集，推理规则如下: 
        自反律: 如果Y∈X∈U，则X→Y在R上成立
        增广律: 如果X→Y为F所蕴含，Z∈U，则XZ→YZ在R上成立
        传递律: 如果X→Y和Y→Z在R上成立，则X→Z在R上成立
        合并律: 如果X→Y和X→Z成立，那么X→YZ成立
        伪传递律: 如果X→Y和WY→Z成立，那么WX→Z成立
        分解律: 如果X→Y和Z∈Y成立，那么X→Z成立
        复合律: 如果X→Y和W→Z成立，那么XW→YZ成立
        如果X→Y和W→Z成立，那么X∪(W-Y)→YZ成立
    11. 多值依赖MVD: 设R(U)是属性集U上的一个关系模式，X,Y是U的子集，若对R(U)的任一关系r，对于X的一个给定的值存在着Y的一组值与其对应，同时Y的这组值又不以任何方式与U-X-Y中的属性相关，那么称Y多值依赖于X，记为X→→Y
    12. 平凡多值依赖：对于属性集U上的一个多值依赖X→→Y，如果Y X或者 XY=U，那么称X→→Y是一个平凡多值依赖

    记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。<br>
    如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。<br>
    对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。<br>
    对于 A->B，B->C，则 A->C 是一个传递函数依赖。<br>

2. ***关系分解***
    1. 关系模式的分解有几个不同的衡量标准: ①分解具有无损连接；②分解要保持函数依赖；③分解既要保持函数依赖，又要具有无损连接
    2. 无损连接性判定定理: 关系模式R分解为两个关系模式R1和R2，满足无损连接性的充分条件是R1 ∩ R2→(R1-R2) 或 R1 ∩ R2→(R2-R1)
    3. 保持函数依赖的定义是: 若满足(F1∪F2)+=F+，则分解保持函数依赖，其中Fi是函数依赖集F在Ri上的投影
    4. 在泛关系模式R分解成数据库模式ρ={R1，R2...Rk}时，泛关系r在ρ的每一模式Ri(1≤i≤n)上投影后再连接起来，比原来r中多出来的元组，称为“寄生元组”或外元组。实际上，寄生元组表示错误的信息
    5. 先存在r(泛关系)的情况下，再去谈论分解，这是关系数据库理论中著名的泛关系假设
    6. 在无泛关系假设时，对两个关系进行自然连接中被丢失的元组称为悬挂元组
    7. 悬挂元组是造成两个关系不存在泛关系的原因
    8. 模式分解的优点: ①能消除数据冗余和操作异常的现象；②在分解了的数据库中可以存储悬挂元组，存储泛关系中无法存储的信息
    9. 模式分解的缺点: ①分解以后，检索操作需要做笛卡尔积或链接操作，这将付出时间代价；②在有泛关系假设时，对数据库中的关系进行自然连接时，可能产生寄生元组(即损失了信息)；在无泛关系假设时，由于数据库可能存在悬挂元组，因此有可能不存在泛关系
    10. 无损分解的测试方法: 
        1. 如果分解后的的关系模式是形如{U1，U2}这，里面只有两个，那很好做，就判断U1 n U2->(U1-U2) or (U2-U1)
        2. https://blog.csdn.net/legendaryhaha/article/details/80649234
    11. 如果某个分解能保持FD集，那么在数据输入或更新时，只要每个关系模式本身的FD约束被满足，就可以确保整个数据库中数据的语义完整性不受破坏
    12. 关系模式在分解时应保持等价，有数据等价和依赖等价两种，分别用无损分解和保持依赖两个特征来衡量。
    13. 数据等价是指两个数据库实例赢表示同样的信息内容。如果是无损分解，那么对泛关系反复的投影和连接都不会丢失信息。
    14. 依赖等价是指两个数据库模式应有相同的依赖集闭包，在依赖集闭包相等的情况下，数据的语义是不会出差错的。
    15. 保持依赖的测试方法: 
        ```
        // 对F上的每一个α→β使用下面的过程：
        result := α;
        while (result发生变化) do
        begin
        　　for each 分解后的Ri
        　　begin
        　　　　t = (result ∩ Ri)+ ∩ Ri
        　　　　result = result ∪ t
        　　end
        end
        ```
    16. 例子: (解答方法: https://blog.csdn.net/weixin_41660162/article/details/83661378)
        1. 设关系模式R(ABCD)，R上的FD集为F={A->C,D->C,BD->A}，试说明ρ={AB,ACD,BCD}相对于F是损失分解的理由。标准解答：据已知的F集，不可能把初始表格修改为有一个全a行的表格，因此ρ相对于F是损失分解。
        2. 设关系模式R(ABCD)，F是R上成立的FD集，F={A->B,B->C,A->D,D->C}，ρ={AB,AC,BD}是R的一个分解。相对于F，ρ是否无损分解？为什么？标准答案：用测试过程可以知道，ρ相对于F是损失分解。
        3. 已知关系模式R(ABCDE)及函数依赖集F={A→C,B→C,C→D,DE→C,CE→A} 验证分解ρ={R1(AD),R2(AB),R3(BE),R4(CDE),R5(AE)}是否为无损连接。 答案:是
    17. http://blog.sina.com.cn/s/blog_6fe0eb1901017mxe.html

3. ***异常***:
    以下的学生课程关系的函数依赖为 Sno, Cname -> Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

    Sno | Sname | Sdept | Mname | Cname | Grade
    :- |:- |:- |:- |:- |:-
    1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90
    2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80
    2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100
    3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95

    不符合范式的关系，会产生很多异常，主要有以下四种异常: 
        - 冗余数据: 例如 学生-2 出现了两次。
        - 修改异常: 修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
        - 删除异常: 删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。
        - 插入异常: 例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

4. ***范式***

    范式理论是为了解决以上提到四种异常。高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。<br>
    <!-- ![范式](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png) -->
    <div align="center"><img alt="范式" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/c2d343f7-604c-4856-9a3c-c71d6f67fecc.png"/></div>

    1. **第一范式 (1NF)**: 属性不可分。

    2. **第二范式 (2NF)**: 每个非主属性完全函数依赖于键码。可以通过分解来满足。**分解前**: 

        Sno | Sname | Sdept | Mname | Cname | Grade
        :- |:- |:- |:- |:- |:-
        1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90
        2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80
        2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100
        3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95

        以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖: 

        - Sno -> Sname, Sdept
        - Sdept -> Mname
        - Sno, Cname-> Grade

        Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，
        这些数据就会出现多次，造成大量冗余数据。**分解后**: 

        关系1: 

        Sno | Sname | Sdept | Mname
        :- |:- |:- |:- 
        1 | 学生-1 | 学院-1 | 院长-1
        2 | 学生-2 | 学院-2 | 院长-2
        3 | 学生-3 | 学院-2 | 院长-2

        有以下函数依赖: Sno -> Sname, Sdept; Sdept -> Mname

        关系2:

        Sno | Cname | Grade
        :- |:- |:-
        1 | 课程-1 | 90
        2 | 课程-2 | 80
        2 | 课程-1 | 100
        3 | 课程-2 | 95

        有以下函数依赖: Sno, Cname -> Grade

    3. **第三范式 (3NF)**: 非主属性不传递函数依赖于键码。上面的 关系-1 中存在以下传递函数依赖: Sno -> Sdept -> Mname; 可以进行以下分解: 

        关系-11

        Sno | Sname | Sdept
        :- |:- |:-
        1 | 学生-1 | 学院-1
        2 | 学生-2 | 学院-2
        3 | 学生-3 | 学院-2

        关系-12

        Sdept | Mname
        :- |:-
        学院-1 | 院长-1
        学院-2 | 院长-2

5. ***关系代数***

    1. 五种基本运算：并，差，笛卡尔积，选择和投影。此外还有除。
    2. 并（Union，∪）：R∪S的联合就是所有在R里面有，或S里面有，或者两个表里面都有的记录集合。
    3. 差（Difference，-）：计算两个表的区别的集合。R-S是在R里面却不在S里面的记录的集合。
    4. 笛卡尔积（Product，X）：计算两个关系的笛卡尔乘积。令R为有K1元的表，令S为有k2元的表。RxS是所有k1+k2元记录的集合，其前k1个元素来自R里德一条记录，而后k2个元素来自S里的一条记录。
    5. 投影（Project，用符号π表示）：从一个表中选取几列的操作。
    6. 选择（Select，用符号σ表示）：从一个表里选取n行记录
    7. 交（Intersection，用符号∩表示）：计算两个表集合理论上的交集。给出表R和S，R∩S是同时在R和S里面的记录的集合。(RuS)-(R-S)-(S-R)
    8. 连接（Join）：两个表先进行笛卡尔乘积，根据相同的属性进行选择，然后用投影把重复的列去掉。即为连接。
    9. 除（Division，用÷来表示）：有两个关系R(X,Y)与关系S(Z)，其中，X,Y,Z为属性集合。假设Y和Z具有相同的属性个数，且对应属性出自相同域。关系R(X,Y)÷S(Z)所得的商关系是关系R在属性X上投影的一个子集，该子集和S(Z)的笛卡尔积必须包含R(X,Y)中。记为R÷S。R在属性X上投影的一个子集：即X属性中的一个子集，即可能为几行数据，后面一句的意思即这个子集中原来对应的数据必须和Z属性中的一样。即为除关系。

#### ER图

Entity-Relationship，有三个组成部分: 实体、属性、联系。用来进行关系型数据库系统的概念设计。

1. ***实体的三种联系***: 包含一对一，一对多，多对多三种。
    - 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；
    - 如果是一对一，画两个带箭头的线段；
    - 如果是多对多，画两个不带箭头的线段。
    
    下图的 Course 和 Student 是一对多的关系。<br>
    <!-- ![一对多](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg) -->
    <div align="center"><img alt="一对多" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/292b4a35-4507-4256-84ff-c218f108ee31.jpg"/></div>
2. ***表示出现多次的关系***: 一个实体在联系出现几次，就要用几条线连接。<br>
    下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。<br>
    <!-- ![多次出现](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg) -->
    <div align="center"><img alt="多次出现" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/8b798007-e0fb-420c-b981-ead215692417.jpg"/></div>
3. ***联系的多向性***: 虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。<br>
    <!-- ![多向性](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png) -->
    <div align="center"><img alt="多向性" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/423f2a40-bee1-488e-b460-8e76c48ee560.png"></div><br>
    一般只使用二元联系，可以把多元联系转换为二元联系。<br>
    <!-- ![二元联系](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png) -->
    <div align="center"><img alt="二元联系" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/de9b9ea0-1327-4865-93e5-6f805c48bc9e.png"></div>
4. ***表示子类***: 用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。<br>
    <!-- ![子类](https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg) -->
    <div align="center"><img alt="子类" src="https://github.com/CyC2018/CS-Notes/raw/master/docs/notes/pics/7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg"></div>